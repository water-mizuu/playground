{
    "sourceFile": "bin/data_structeur/range_1d.dart",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 2,
            "patches": [
                {
                    "date": 1688828962740,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1688828994742,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -172,10 +172,10 @@\n             Range left = Range.unit(min(start, other.start), other.start);\r\n             Range right = Range.unit(other.end, max(other.end, end));\r\n \r\n             Set<RangeUnit> units = <RangeUnit>{\r\n-              if (left case RangeUnit _) left,\r\n-              if (right case RangeUnit _) right,\r\n+              if (Range.unit(min(start, other.start), other.start) case RangeUnit left) left,\r\n+              if (Range.unit(other.end, max(other.end, end)) case RangeUnit _) right,\r\n             };\r\n \r\n             if (units.isEmpty) {\r\n               return Range.empty();\r\n"
                },
                {
                    "date": 1688830049784,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -168,22 +168,19 @@\n   @override\r\n   Range difference(Range other) => switch (other) {\r\n         void _ when !this.intersects(other) || other.isEmpty => this,\r\n         RangeUnit other => () {\r\n-            Range left = Range.unit(min(start, other.start), other.start);\r\n-            Range right = Range.unit(other.end, max(other.end, end));\r\n-\r\n             Set<RangeUnit> units = <RangeUnit>{\r\n               if (Range.unit(min(start, other.start), other.start) case RangeUnit left) left,\r\n-              if (Range.unit(other.end, max(other.end, end)) case RangeUnit _) right,\r\n+              if (Range.unit(other.end, max(other.end, end)) case RangeUnit right) right,\r\n             };\r\n \r\n             if (units.isEmpty) {\r\n               return Range.empty();\r\n             } else if (units.length == 1) {\r\n               return units.single;\r\n             } else {\r\n-              return Range.union(units);  \r\n+              return Range.union(units);\r\n             }\r\n           }(),\r\n         RangeUnion other => other.units.fold(this, (Range v, RangeUnit unit) => v.difference(unit)),\r\n         RangeEmpty() => this,\r\n@@ -280,28 +277,8 @@\n   final Set<RangeUnit> units;\r\n \r\n   const RangeUnion(this.units);\r\n \r\n-  /// Returns an \"equivalent\" [RangeUnit] that contains the same [RangeUnit.start]\r\n-  ///   and [RangeUnit.end] as the units leftmost and rightmost unit values.\r\n-  RangeUnit contingent() {\r\n-    int? start;\r\n-    int? end;\r\n-    for (RangeUnit unit in units) {\r\n-      start ??= unit.start;\r\n-      end ??= unit.end;\r\n-\r\n-      start = min(start, unit.start);\r\n-      end = max(end, unit.end);\r\n-    }\r\n-\r\n-    if (start == null || end == null) {\r\n-      throw StateError(\"Empty union!\");\r\n-    }\r\n-\r\n-    return RangeUnit(start, end);\r\n-  }\r\n-\r\n   @override\r\n   bool covers(Range other) {\r\n     return units.any((RangeUnit r) => r.covers(other));\r\n   }\r\n"
                }
            ],
            "date": 1688828962740,
            "name": "Commit-0",
            "content": "import \"dart:collection\";\r\nimport \"dart:math\";\r\n\r\nclass RangeSet with SetMixin<num> implements Set<num> {\r\n  Range inner;\r\n\r\n  RangeSet(this.inner);\r\n  RangeSet.empty() : inner = Range.empty();\r\n\r\n  @override\r\n  bool add(num value) {\r\n    if (inner.contains(value)) {\r\n      return false;\r\n    }\r\n    int floored = value.floor();\r\n    inner |= Range.unit(floored, floored + 1);\r\n\r\n    return true;\r\n  }\r\n\r\n  @override\r\n  bool contains(Object? element) {\r\n    return inner.contains(element);\r\n  }\r\n\r\n  @override\r\n  Iterator<int> get iterator => inner.iterator;\r\n\r\n  @override\r\n  int get length => inner.length;\r\n\r\n  @override\r\n  num? lookup(Object? element) {\r\n    return element is num && inner.contains(element) ? element : null;\r\n  }\r\n\r\n  @override\r\n  bool remove(Object? value) {\r\n    if (value is! num || !inner.contains(value)) {\r\n      return false;\r\n    }\r\n\r\n    int floored = value.floor();\r\n    inner -= Range.unit(floored, floored + 1);\r\n\r\n    return true;\r\n  }\r\n\r\n  @override\r\n  Set<num> toSet() {\r\n    return RangeSet(inner);\r\n  }\r\n\r\n  @override\r\n  String toString() => inner.toString();\r\n}\r\n\r\nsealed class Range extends Iterable<int> {\r\n  const Range();\r\n\r\n  /// Returns an empty [Range]. The equivalent set of values this iterable has is the empty set.\r\n  const factory Range.empty() = RangeEmpty;\r\n\r\n  /// Returns a [RangeUnit]. It represents a continuous set of integers from [start] to [end],\r\n  ///   with an inclusive [start] but an exclusive [end]. This is the smallest unit that a\r\n  ///   [Range] of numbers can be represented with.\r\n  factory Range.unit(int start, int end) {\r\n    if (end <= start) {\r\n      return Range.empty();\r\n    }\r\n    return RangeUnit(start, end);\r\n  }\r\n\r\n  /// Returns a [RangeUnion]. This represents a collection of [RangeUnit] that aren't continuous,\r\n  ///   but nevertheless is from the same [Range].\r\n  factory Range.union(Set<RangeUnit> units) {\r\n    units = <RangeUnit>{\r\n      for (RangeUnit unit in units)\r\n        if (unit.isNotEmpty) unit\r\n    };\r\n    if (units.isEmpty) {\r\n      return Range.empty();\r\n    }\r\n    return RangeUnion(units);\r\n  }\r\n  factory Range.fromSet(Set<int> numbers) {\r\n    List<int> sorted = numbers.toList()..sort();\r\n    Set<RangeUnit> runs = <RangeUnit>{};\r\n\r\n    int? start;\r\n    for (int i = 0; i < sorted.length; ++i) {\r\n      start = sorted[i];\r\n\r\n      while (i + 1 < sorted.length && sorted[i + 1] - sorted[i] == 1) {\r\n        i++;\r\n      }\r\n\r\n      runs.add(RangeUnit(start, sorted[i] + 1));\r\n    }\r\n\r\n    if (runs case Range(length: 1)) {\r\n      return runs.single;\r\n    }\r\n\r\n    return RangeUnion(runs);\r\n  }\r\n\r\n  /// Returns the intersection (common element) of a range.\r\n  Range intersection(Range other);\r\n\r\n  /// Returns the union of a range.\r\n  Range union(Range other);\r\n\r\n  /// Returns the difference of two ranges. If the rhs (right hand side) does not\r\n  ///   intersect with the lhs (left hand side), then the lhs is returned unmodified.\r\n  Range difference(Range other);\r\n\r\n  /// Returns `true` if the [Range] intersects with another [Range].\r\n  bool intersects(Range other);\r\n\r\n  /// Returns `true` if the [Range] `this` covers or is a superset of another [Range]\r\n  bool covers(Range other);\r\n\r\n  @override\r\n  bool contains(Object? value);\r\n\r\n  Range operator |(Range other) => union(other);\r\n  Range operator &(Range other) => intersection(other);\r\n  Range operator -(Range other) => difference(other);\r\n\r\n  Range operator ^(Range other) => (this | other) - (this & other);\r\n\r\n  @override\r\n  // ignore: hash_and_equals\r\n  bool operator ==(Object other) => other is Range && this.covers(other) && other.covers(this);\r\n\r\n  @override\r\n  String toString() => \"∅\";\r\n}\r\n\r\nclass RangeUnit extends Range {\r\n  final int start;\r\n  final int end;\r\n\r\n  const RangeUnit(this.start, this.end);\r\n\r\n  /// Returns the contingent combination of two [RangeUnit]s,\r\n  ///   returning an equivalent [RangeUnit]\r\n  Range combination(RangeUnit other) {\r\n    int start = min(this.start, other.start);\r\n    int end = max(this.end, other.end);\r\n    if (start >= end) {\r\n      return Range.empty();\r\n    }\r\n\r\n    return Range.unit(start, end);\r\n  }\r\n\r\n  @override\r\n  bool covers(Range other) {\r\n    return switch (other) {\r\n      RangeUnit other => this.start <= other.start && this.end >= other.end,\r\n      RangeUnion other => other.units.every(this.covers),\r\n      RangeEmpty() => true,\r\n    };\r\n  }\r\n\r\n  @override\r\n  Range difference(Range other) => switch (other) {\r\n        void _ when !this.intersects(other) || other.isEmpty => this,\r\n        RangeUnit other => () {\r\n            Range left = Range.unit(min(start, other.start), other.start);\r\n            Range right = Range.unit(other.end, max(other.end, end));\r\n\r\n            Set<RangeUnit> units = <RangeUnit>{\r\n              if (left case RangeUnit _) left,\r\n              if (right case RangeUnit _) right,\r\n            };\r\n\r\n            if (units.isEmpty) {\r\n              return Range.empty();\r\n            } else if (units.length == 1) {\r\n              return units.single;\r\n            } else {\r\n              return Range.union(units);  \r\n            }\r\n          }(),\r\n        RangeUnion other => other.units.fold(this, (Range v, RangeUnit unit) => v.difference(unit)),\r\n        RangeEmpty() => this,\r\n      };\r\n\r\n  @override\r\n  bool intersects(Range other) => switch (other) {\r\n        RangeUnit other => !(this.start > other.end || this.end <= other.start),\r\n        RangeUnion other => other.units.any(this.intersects),\r\n        RangeEmpty() => true,\r\n      };\r\n\r\n  @override\r\n  Range intersection(Range other) {\r\n    if (this.isEmpty || other.isEmpty) {\r\n      return Range.empty();\r\n    }\r\n\r\n    if (!this.intersects(other)) {\r\n      return Range.empty();\r\n    }\r\n\r\n    switch (other) {\r\n      case RangeUnit _:\r\n        return Range.unit(max(this.start, other.start), min(this.end, other.end));\r\n      case RangeUnion _:\r\n        return other.units.fold(this, (Range range, RangeUnit unit) => range.intersection(unit));\r\n      case RangeEmpty _:\r\n        return other;\r\n    }\r\n  }\r\n\r\n  @override\r\n  Range union(Range other) {\r\n    if (this.isEmpty) {\r\n      return other;\r\n    }\r\n    if (other.isEmpty) {\r\n      return this;\r\n    }\r\n\r\n    /// At this point, neither of them should be empty.\r\n    if (other is RangeUnit && other.start - this.end == 0) {\r\n      /// This is a special case for when [a, b) | [b, c)\r\n      ///   can be simplified to [a, c).\r\n      return this.combination(other);\r\n    }\r\n\r\n    if (!this.intersects(other)) {\r\n      /// Since this doesn't intersect, then\r\n\r\n      return switch (other) {\r\n        RangeUnit other => <RangeUnit>{this, other}.toRangeUnion(),\r\n        RangeUnion other => <RangeUnit>{this, ...other.units}.toRangeUnion(),\r\n        RangeEmpty() => this,\r\n      };\r\n    }\r\n\r\n    /// At this point, it's guaranteed to intersect somewhere.\r\n    return switch (other) {\r\n      RangeUnit other => this.combination(other),\r\n      RangeUnion other => other.units.fold(this, (Range l, RangeUnit r) => l.union(r)),\r\n      RangeEmpty() => this,\r\n    };\r\n  }\r\n\r\n  @override\r\n  bool contains(Object? value) {\r\n    return value is num && start <= value && value < end;\r\n  }\r\n\r\n  @override\r\n  int get length => (end - start).clamp(0, double.maxFinite.toInt());\r\n\r\n  @override\r\n  Iterator<int> get iterator => () sync* {\r\n        for (int i = start; i < end; ++i) {\r\n          yield i;\r\n        }\r\n      }()\r\n          .iterator;\r\n\r\n  @override\r\n  String toString() => this.isEmpty ? \"∅\" : \"[$start, $end)\";\r\n\r\n  @override\r\n  bool operator ==(Object other) => other is RangeUnit && start == other.start && end == other.end;\r\n\r\n  @override\r\n  int get hashCode => (start, end).hashCode;\r\n}\r\n\r\nclass RangeUnion extends Range {\r\n  final Set<RangeUnit> units;\r\n\r\n  const RangeUnion(this.units);\r\n\r\n  /// Returns an \"equivalent\" [RangeUnit] that contains the same [RangeUnit.start]\r\n  ///   and [RangeUnit.end] as the units leftmost and rightmost unit values.\r\n  RangeUnit contingent() {\r\n    int? start;\r\n    int? end;\r\n    for (RangeUnit unit in units) {\r\n      start ??= unit.start;\r\n      end ??= unit.end;\r\n\r\n      start = min(start, unit.start);\r\n      end = max(end, unit.end);\r\n    }\r\n\r\n    if (start == null || end == null) {\r\n      throw StateError(\"Empty union!\");\r\n    }\r\n\r\n    return RangeUnit(start, end);\r\n  }\r\n\r\n  @override\r\n  bool covers(Range other) {\r\n    return units.any((RangeUnit r) => r.covers(other));\r\n  }\r\n\r\n  @override\r\n  Range difference(Range other) {\r\n    if (!this.intersects(other)) {\r\n      return this;\r\n    }\r\n\r\n    Set<RangeUnit> units = <RangeUnit>{};\r\n    for (RangeUnit unit in this.units) {\r\n      switch (unit.difference(other)) {\r\n        case RangeUnit difference when difference != Range.empty():\r\n          units.add(difference);\r\n          break;\r\n        case RangeUnion difference:\r\n          units.addAll(difference.units);\r\n          break;\r\n        case RangeEmpty _:\r\n        default:\r\n          break;\r\n      }\r\n    }\r\n\r\n    return RangeUnion(units);\r\n  }\r\n\r\n  @override\r\n  Range intersection(Range other) {\r\n    return units.fold(other, (Range r, RangeUnit unit) => unit.intersection(r));\r\n  }\r\n\r\n  @override\r\n  bool intersects(Range other) {\r\n    return units.any((RangeUnit r) => r.intersects(other));\r\n  }\r\n\r\n  @override\r\n  Range union(Range other) {\r\n    return units.fold(other, (Range r, RangeUnit unit) => unit.union(r));\r\n  }\r\n\r\n  @override\r\n  bool contains(Object? value) {\r\n    return value is num && units.isNotEmpty && units.any((RangeUnit u) => u.contains(value));\r\n  }\r\n\r\n  @override\r\n  int get length => units.map((RangeUnit u) => u.length).fold(0, (int a, int b) => a + b);\r\n\r\n  @override\r\n  Iterator<int> get iterator => () sync* {\r\n        for (RangeUnit unit in units) {\r\n          for (int v in unit) {\r\n            yield v;\r\n          }\r\n        }\r\n      }()\r\n          .iterator;\r\n\r\n  @override\r\n  String toString() => isEmpty ? \"∅\" : units.join(\" | \");\r\n}\r\n\r\nclass RangeEmpty extends Range {\r\n  const RangeEmpty();\r\n\r\n  @override\r\n  bool covers(Range other) {\r\n    return other is RangeEmpty;\r\n  }\r\n\r\n  @override\r\n  Range difference(Range other) {\r\n    return this;\r\n  }\r\n\r\n  @override\r\n  Range intersection(Range other) {\r\n    return this;\r\n  }\r\n\r\n  @override\r\n  bool intersects(Range other) {\r\n    return false;\r\n  }\r\n\r\n  @override\r\n  Iterator<int> get iterator => () sync* {}().cast<int>().iterator;\r\n\r\n  @override\r\n  Range union(Range other) {\r\n    return other;\r\n  }\r\n\r\n  @override\r\n  int get length => 0;\r\n\r\n  @override\r\n  bool get isEmpty => true;\r\n\r\n  @override\r\n  bool get isNotEmpty => false;\r\n\r\n  @override\r\n  bool operator ==(Object other) => other is RangeEmpty;\r\n\r\n  @override\r\n  int get hashCode => const <int>{}.hashCode;\r\n\r\n  @override\r\n  String toString() => \"∅\";\r\n}\r\n\r\nextension on Set<RangeUnit> {\r\n  RangeUnion toRangeUnion() => RangeUnion(this);\r\n}\r\n"
        }
    ]
}