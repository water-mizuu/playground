{
    "sourceFile": "bin/data_structeur/avl_tree.dart",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1698396616594,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1698396616594,
            "name": "Commit-0",
            "content": "// ignore_for_file: avoid_returning_this\r\n\r\nimport \"dart:collection\";\r\nimport \"dart:math\" as math;\r\n\r\nextension AvlTreeNodeNullableMethods<E> on AvlTreeNode<E>? {\r\n  int get height {\r\n    AvlTreeNode<E>? self = this;\r\n    if (self == null) {\r\n      return 0;\r\n    }\r\n\r\n    return 1 + math.max(self.left.height, self.right.height);\r\n  }\r\n\r\n  int get balanceFactor {\r\n    AvlTreeNode<E>? self = this;\r\n    if (self == null) {\r\n      return 0;\r\n    }\r\n\r\n    int leftHeight = self.left.height;\r\n    int rightHeight = self.right.height;\r\n\r\n    return leftHeight - rightHeight;\r\n  }\r\n}\r\n\r\nclass AvlTreeNode<E> {\r\n  static final math.Random _random = math.Random();\r\n  final int Function(E, E) comparison;\r\n\r\n  E value;\r\n  AvlTreeNode<E>? left;\r\n  AvlTreeNode<E>? right;\r\n\r\n  AvlTreeNode({required this.value, required this.comparison, this.left, this.right});\r\n\r\n  AvlTreeNode<E> _rotateLeft() {\r\n    AvlTreeNode<E> rightChild = this.right!;\r\n    AvlTreeNode<E>? temp = rightChild.left;\r\n    rightChild.left = this;\r\n    this.right = temp;\r\n\r\n    return rightChild;\r\n  }\r\n\r\n  AvlTreeNode<E> _rotateRight() {\r\n    AvlTreeNode<E> leftChild = this.left!;\r\n    AvlTreeNode<E>? temp = leftChild.right;\r\n    leftChild.right = this;\r\n    this.left = temp;\r\n\r\n    return leftChild;\r\n  }\r\n\r\n  AvlTreeNode<E> _balance() {\r\n    int factor = balanceFactor;\r\n\r\n    if (factor > 1) {\r\n      if (left.balanceFactor > 0) {\r\n        return _rotateRight();\r\n      } else {\r\n        left = left?._rotateLeft();\r\n        return _rotateRight();\r\n      }\r\n    } else if (factor < -1) {\r\n      if (right.balanceFactor < 0) {\r\n        return _rotateLeft();\r\n      } else {\r\n        right = right?._rotateRight();\r\n        return _rotateLeft();\r\n      }\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  String asciiTree({String indent = \"\", bool isLast = true}) {\r\n    StringBuffer buffer = StringBuffer();\r\n    String marker = isLast ? \"└─\" : \"├─\";\r\n\r\n    buffer\r\n      ..write(indent)\r\n      ..write(marker)\r\n      ..write(\" \");\r\n    buffer.writeln(\"$value\");\r\n\r\n    String newIndent = \"$indent${isLast ? \"   \" : \"│  \"}\";\r\n    AvlTreeNode<void>? last = right ?? left;\r\n    AvlTreeNode<void>? pre = last == left ? null : left;\r\n\r\n    buffer.write(pre?.asciiTree(indent: newIndent, isLast: false) ?? \"\");\r\n    buffer.write(last?.asciiTree(indent: newIndent) ?? \"\");\r\n\r\n    return buffer.toString();\r\n  }\r\n\r\n  (AvlTreeNode<E>, bool) add(E value) {\r\n    bool inserted = false;\r\n    if (comparison(value, this.value) < 0) {\r\n      var (AvlTreeNode<E> node, bool _inserted) =\r\n          this.left?.add(value) ?? (AvlTreeNode<E>(value: value, comparison: comparison), true);\r\n\r\n      inserted = _inserted;\r\n      this.left = node;\r\n    } else if (comparison(value, this.value) > 0) {\r\n      var (AvlTreeNode<E> node, bool _inserted) =\r\n          this.right?.add(value) ?? (AvlTreeNode<E>(value: value, comparison: comparison), true);\r\n\r\n      inserted = _inserted;\r\n      this.right = node;\r\n    }\r\n\r\n    return (this._balance(), inserted);\r\n  }\r\n\r\n  (AvlTreeNode<E>?, bool) remove(E value) {\r\n    bool removed = false;\r\n    int compare = comparison(value, this.value);\r\n\r\n    if (compare < 0) {\r\n      if (this.left case AvlTreeNode<E> left) {\r\n        var (AvlTreeNode<E>? node, bool _removed) = left.remove(value);\r\n        this.left = node;\r\n        removed = _removed;\r\n      }\r\n    } else if (compare > 0) {\r\n      if (this.right case AvlTreeNode<E> right) {\r\n        var (AvlTreeNode<E>? node, bool _removed) = right.remove(value);\r\n        this.right = node;\r\n        removed = _removed;\r\n      }\r\n    } else {\r\n      if (this.left == null) {\r\n        return (this.right, true);\r\n      } else if (this.right == null) {\r\n        return (this.left, true);\r\n      } else {\r\n        if (this.right case AvlTreeNode<E> right) {\r\n          E value = right.minValueNode.value;\r\n          var (AvlTreeNode<E>? node, bool _removed) = right.remove(value);\r\n          this.value = value;\r\n          this.right = node;\r\n          removed = _removed;\r\n        }\r\n      }\r\n    }\r\n\r\n    return (this._balance(), removed);\r\n  }\r\n\r\n  AvlTreeNode<E>? lookup(E value) {\r\n    int key = comparison(value, this.value);\r\n    if (key < 0) {\r\n      return left?.lookup(value);\r\n    } else if (key > 0) {\r\n      return right?.lookup(value);\r\n    } else if (key == 0) {\r\n      return this;\r\n    }\r\n    return null;\r\n  }\r\n\r\n  AvlTreeNode<E> random(Expando<int> expando) {\r\n    int r = _random.nextInt(expando[this] ??= length);\r\n\r\n    if (r == 0) {\r\n      return this;\r\n    } else if (left case AvlTreeNode<E> left) {\r\n      if (1 <= r && r <= left.length) {\r\n        return left.random(expando);\r\n      }\r\n    }\r\n\r\n    return right?.random(expando) ?? this;\r\n  }\r\n\r\n  AvlTreeNode<E> get minValueNode {\r\n    AvlTreeNode<E>? left = this.left;\r\n    if (left == null) {\r\n      return this;\r\n    }\r\n    return left.minValueNode;\r\n  }\r\n\r\n  int get length => 1 + (left?.length ?? 0) + (right?.length ?? 0);\r\n\r\n  @override\r\n  String toString() => \"[$value, $left, $right]\";\r\n}\r\n\r\nclass AvlTree<E> extends Iterable<E> with SetMixin<E> {\r\n  final int Function(E, E) comparison;\r\n  AvlTreeNode<E>? head;\r\n\r\n  AvlTree([int Function(E, E)? comparison])\r\n      : comparison = comparison ?? ((E a, E b) => (a as Comparable<dynamic>).compareTo(b));\r\n\r\n  factory AvlTree.from(Iterable<E> iterable, [int Function(E, E)? comparison]) {\r\n    AvlTree<E> tree = AvlTree<E>(comparison);\r\n    tree.addAll(iterable);\r\n\r\n    return tree;\r\n  }\r\n\r\n  @override\r\n  int get length => head?.length ?? 0;\r\n\r\n  @override\r\n  bool add(E value) {\r\n    if (head case AvlTreeNode<E> head) {\r\n      var (AvlTreeNode<E> node, bool found) = head.add(value);\r\n      this.head = node;\r\n\r\n      return found;\r\n    } else {\r\n      this.head = AvlTreeNode<E>(value: value, comparison: comparison);\r\n\r\n      return true;\r\n    }\r\n  }\r\n\r\n  @override\r\n  bool remove(Object? value) {\r\n    if (value is! E) {\r\n      return false;\r\n    }\r\n\r\n    if (this.head case AvlTreeNode<E> head) {\r\n      var (AvlTreeNode<E>? newHead, bool removed) = head.remove(value);\r\n      this.head = newHead;\r\n\r\n      return removed;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  @override\r\n  String toString() => head?.asciiTree() ?? \"\";\r\n\r\n  @override\r\n  Iterator<E> get iterator => () sync* {\r\n        if (this.head case AvlTreeNode<E> head) {\r\n          Queue<AvlTreeNode<E>> stack = Queue<AvlTreeNode<E>>();\r\n          AvlTreeNode<E>? current = head;\r\n\r\n          while (true) {\r\n            if (current != null) {\r\n              stack.addLast(current);\r\n              current = current.left;\r\n            } else if (stack.isNotEmpty) {\r\n              current = stack.removeLast();\r\n              yield current.value;\r\n              current = current.right;\r\n            } else {\r\n              break;\r\n            }\r\n          }\r\n        }\r\n      }()\r\n          .iterator;\r\n\r\n  @override\r\n  E? lookup(Object? element) {\r\n    if (head == null || element is! E) {\r\n      return null;\r\n    }\r\n\r\n    return head?.lookup(element)?.value;\r\n  }\r\n\r\n  @override\r\n  AvlTree<E> toSet() {\r\n    AvlTree<E> tree = AvlTree<E>();\r\n\r\n    if (head case AvlTreeNode<E> head) {\r\n      Queue<AvlTreeNode<E>> stack = Queue<AvlTreeNode<E>>()..add(head);\r\n\r\n      while (stack.isNotEmpty) {\r\n        var AvlTreeNode<E>(\r\n          value: E value,\r\n          left: AvlTreeNode<E>? left,\r\n          right: AvlTreeNode<E>? right,\r\n        ) = stack.removeFirst();\r\n\r\n        tree.add(value);\r\n\r\n        if (left case AvlTreeNode<E> node) {\r\n          stack.addLast(node);\r\n        }\r\n        if (right case AvlTreeNode<E> node) {\r\n          stack.addLast(node);\r\n        }\r\n      }\r\n    }\r\n\r\n    return tree;\r\n  }\r\n\r\n  E random() {\r\n    if (head case AvlTreeNode<E> head) {\r\n      return head.random(Expando<int>()).value;\r\n    }\r\n    throw StateError(\"no element\");\r\n  }\r\n\r\n  @override\r\n  E get first {\r\n    if (head case AvlTreeNode<E> head) {\r\n      AvlTreeNode<E> node = head;\r\n      while (node.left != null) {\r\n        node = node.left!;\r\n      }\r\n\r\n      return node.value;\r\n    }\r\n    throw StateError(\"no elements\");\r\n  }\r\n\r\n  @override\r\n  E get last {\r\n    if (head case AvlTreeNode<E> head) {\r\n      AvlTreeNode<E> node = head;\r\n      while (node.right != null) {\r\n        node = node.right!;\r\n      }\r\n\r\n      return node.value;\r\n    }\r\n    throw StateError(\"no elements\");\r\n  }\r\n}\r\n"
        }
    ]
}