{
    "sourceFile": "bin/data_structeur/list_slice.dart",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1698396618233,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1698396618233,
            "name": "Commit-0",
            "content": "import \"dart:math\";\r\n\r\nextension ListSliceExtension<E> on List<E> {\r\n  ListSlice<E> slice(int start, [int end = 0]) => ListSlice<E>(this, start, end == 0 ? length : end);\r\n}\r\n\r\nclass ListSlice<E> implements List<E> {\r\n  final List<E> list;\r\n  final int start;\r\n  final int end;\r\n\r\n  const ListSlice(this.list, int start, int end)\r\n      : assert(list.length > 0, \"A list must have at least one element to have a slice.\"),\r\n        start = start > 0 ? start : start % list.length,\r\n        end = end > 0 ? end : end % list.length;\r\n\r\n  @override\r\n  E get first => list[start];\r\n\r\n  @override\r\n  void set first(E _) => throw UnsupportedError(\"Cannot set item to slice!\");\r\n\r\n  @override\r\n  E get last => list[end - 1];\r\n\r\n  @override\r\n  void set last(E _) => throw UnsupportedError(\"Cannot set item to slice!\");\r\n\r\n  @override\r\n  int get length => end - start;\r\n\r\n  @override\r\n  void set length(int _) => throw UnsupportedError(\"Cannot change slice size!\");\r\n\r\n  @override\r\n  Never operator +(List<E> other) {\r\n    throw UnimplementedError();\r\n  }\r\n\r\n  @override\r\n  E operator [](int index) {\r\n    return list[start + index];\r\n  }\r\n\r\n  @override\r\n  void operator []=(int index, E value) => throw UnsupportedError(\"Cannot mutate list from slice!\");\r\n\r\n  @override\r\n  Never add(E value) => throw UnsupportedError(\"Cannot mutate list from slice!\");\r\n\r\n  @override\r\n  Never addAll(Iterable<E> iterable) => throw UnsupportedError(\"Cannot mutate list from slice!\");\r\n\r\n  @override\r\n  bool any(bool Function(E element) test) {\r\n    bool found = false;\r\n    for (int i = start; i < end; ++i) {\r\n      if (found = test(list[i])) {\r\n        break;\r\n      }\r\n    }\r\n\r\n    return found;\r\n  }\r\n\r\n  @override\r\n  Map<int, E> asMap() => <int, E>{for (int i = start; i < end; ++i) i: list[i]};\r\n\r\n  @override\r\n  List<R> cast<R>() => list.sublist(start, end).cast<R>();\r\n\r\n  @override\r\n  Never clear() => throw UnsupportedError(\"Cannot mutate list from slice!\");\r\n\r\n  @override\r\n  bool contains(Object? element) {\r\n    for (int i = start; i < end; ++i) {\r\n      if (list[i] == element) {\r\n        return true;\r\n      }\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  @override\r\n  E elementAt(int index) {\r\n    return list[start + index];\r\n  }\r\n\r\n  @override\r\n  bool every(bool Function(E element) test) {\r\n    bool found = true;\r\n    for (int i = start; i < end; ++i) {\r\n      if (!(found = test(list[i]))) {\r\n        break;\r\n      }\r\n    }\r\n\r\n    return found;\r\n  }\r\n\r\n  @override\r\n  Iterable<T> expand<T>(Iterable<T> Function(E element) toElements) sync* {\r\n    for (int i = start; i < end; ++i) {\r\n      yield* toElements(list[i]);\r\n    }\r\n  }\r\n\r\n  @override\r\n  Never fillRange(int start, int end, [E? fillValue]) => throw UnsupportedError(\"Cannot mutate list from slice!\");\r\n\r\n  @override\r\n  E firstWhere(bool Function(E element) test, {E Function()? orElse}) {\r\n    for (int i = start; i < end; ++i) {\r\n      if (test(list[i])) {\r\n        return list[i];\r\n      }\r\n    }\r\n\r\n    return orElse?.call() ?? (throw StateError(\"No element\"));\r\n  }\r\n\r\n  @override\r\n  T fold<T>(T initialValue, T Function(T previousValue, E element) combine) {\r\n    T value = initialValue;\r\n    for (int i = start; i < end; ++i) {\r\n      value = combine(value, list[i]);\r\n    }\r\n    return value;\r\n  }\r\n\r\n  @override\r\n  Iterable<E> followedBy(Iterable<E> other) sync* {\r\n    for (int i = start; i < end; ++i) {\r\n      yield list[i];\r\n    }\r\n    yield* other;\r\n  }\r\n\r\n  @override\r\n  void forEach(void Function(E element) action) {\r\n    for (int i = start; i < end; ++i) {\r\n      action(list[i]);\r\n    }\r\n  }\r\n\r\n  @override\r\n  Iterable<E> getRange(int start, int end) {\r\n    assert(end + this.start <= this.end, \"Range must not exceed slice bounds!\");\r\n\r\n    return list.getRange(start + this.start, end + this.start);\r\n  }\r\n\r\n  @override\r\n  int indexOf(E element, [int start = 0]) {\r\n    for (int i = this.start + start; i < end; ++i) {\r\n      if (list[i] == element) {\r\n        return i;\r\n      }\r\n    }\r\n\r\n    return -1;\r\n  }\r\n\r\n  @override\r\n  int indexWhere(bool Function(E element) test, [int start = 0]) {\r\n    for (int i = this.start + start; i < end; ++i) {\r\n      if (test(list[i])) {\r\n        return i;\r\n      }\r\n    }\r\n    return -1;\r\n  }\r\n\r\n  @override\r\n  Never insert(int index, E element) => throw UnsupportedError(\"Cannot mutate list from slice!\");\r\n\r\n  @override\r\n  Never insertAll(int index, Iterable<E> iterable) => throw UnsupportedError(\"Cannot mutate list from slice!\");\r\n\r\n  @override\r\n  bool get isEmpty => end - start + 1 == 0;\r\n\r\n  @override\r\n  bool get isNotEmpty => end - start + 1 > 0;\r\n\r\n  @override\r\n  Iterator<E> get iterator {\r\n    return () sync* {\r\n      for (int i = start; i < end; ++i) {\r\n        yield list[i];\r\n      }\r\n    }()\r\n        .iterator;\r\n  }\r\n\r\n  @override\r\n  String join([String separator = \"\"]) {\r\n    StringBuffer buffer = StringBuffer();\r\n    for (int i = start; i < end; ++i) {\r\n      if (i > start) {\r\n        buffer.write(separator);\r\n      }\r\n      buffer.write(list[i]);\r\n    }\r\n\r\n    return buffer.toString();\r\n  }\r\n\r\n  @override\r\n  int lastIndexOf(E element, [int? start]) {\r\n    for (int i = end - 1; i >= this.start + (start ?? 0); --i) {\r\n      if (list[i] == element) {\r\n        return i;\r\n      }\r\n    }\r\n\r\n    return -1;\r\n  }\r\n\r\n  @override\r\n  int lastIndexWhere(bool Function(E element) test, [int? start]) {\r\n    for (int i = end - 1; i >= this.start + (start ?? 0); --i) {\r\n      if (test(list[i])) {\r\n        return i;\r\n      }\r\n    }\r\n\r\n    return -1;\r\n  }\r\n\r\n  @override\r\n  E lastWhere(bool Function(E element) test, {E Function()? orElse}) {\r\n    for (int i = end - 1; i >= start; --i) {\r\n      if (test(list[i])) {\r\n        return list[i];\r\n      }\r\n    }\r\n\r\n    throw StateError(\"No match\");\r\n  }\r\n\r\n  @override\r\n  Iterable<T> map<T>(T Function(E e) toElement) sync* {\r\n    for (int i = start; i < end; ++i) {\r\n      yield toElement(list[i]);\r\n    }\r\n  }\r\n\r\n  @override\r\n  E reduce(E Function(E value, E element) combine) {\r\n    E value = list[start];\r\n    for (int i = start + 1; i < end; ++i) {\r\n      value = combine(value, list[i]);\r\n    }\r\n    return value;\r\n  }\r\n\r\n  @override\r\n  bool remove(Object? value) => throw UnsupportedError(\"Cannot mutate list from slice!\");\r\n\r\n  @override\r\n  E removeAt(int index) => throw UnsupportedError(\"Cannot mutate list from slice!\");\r\n\r\n  @override\r\n  E removeLast() => throw UnsupportedError(\"Cannot mutate list from slice!\");\r\n\r\n  @override\r\n  Never removeRange(int start, int end) => throw UnsupportedError(\"Cannot mutate list from slice!\");\r\n\r\n  @override\r\n  Never removeWhere(bool Function(E element) test) => throw UnsupportedError(\"Cannot mutate list from slice!\");\r\n\r\n  @override\r\n  Never replaceRange(int start, int end, Iterable<E> replacements) =>\r\n      throw UnsupportedError(\"Cannot mutate list from slice!\");\r\n\r\n  @override\r\n  Never retainWhere(bool Function(E element) test) => throw UnsupportedError(\"Cannot mutate list from slice!\");\r\n\r\n  @override\r\n  Iterable<E> get reversed sync* {\r\n    for (int i = end - 1; i >= start; --i) {\r\n      yield list[i];\r\n    }\r\n  }\r\n\r\n  @override\r\n  Never setAll(int index, Iterable<E> iterable) => throw UnsupportedError(\"Cannot mutate list from slice!\");\r\n\r\n  @override\r\n  Never setRange(int start, int end, Iterable<E> iterable, [int skipCount = 0]) =>\r\n      throw UnsupportedError(\"Cannot mutate list from slice!\");\r\n\r\n  @override\r\n  Never shuffle([Random? random]) => throw UnsupportedError(\"Cannot mutate list from slice!\");\r\n\r\n  @override\r\n  E get single {\r\n    if (length == 0) {\r\n      throw StateError(\"Slice is empty!\");\r\n    }\r\n    if (length != 1) {\r\n      throw StateError(\"Too many elements\");\r\n    }\r\n\r\n    return list[start];\r\n  }\r\n\r\n  @override\r\n  E singleWhere(bool Function(E element) test, {E Function()? orElse}) {\r\n    E? found;\r\n    for (int i = start; i < end; ++i) {\r\n      if (test(list[i])) {\r\n        if (found == null) {\r\n          found = list[i];\r\n        } else {\r\n          throw StateError(\"Too many elements\");\r\n        }\r\n      }\r\n    }\r\n\r\n    return found ?? orElse?.call() ?? (throw StateError(\"No elements\"));\r\n  }\r\n\r\n  @override\r\n  Iterable<E> skip(int count) sync* {\r\n    for (int i = start + count; i < end; ++i) {\r\n      yield list[i];\r\n    }\r\n  }\r\n\r\n  @override\r\n  Iterable<E> skipWhile(bool Function(E value) test) sync* {\r\n    bool skipping = true;\r\n    for (int i = start; i < end; ++i) {\r\n      if (skipping) {\r\n        skipping = test(list[i]);\r\n      } else {\r\n        yield list[i];\r\n      }\r\n    }\r\n  }\r\n\r\n  @override\r\n  Never sort([int Function(E a, E b)? compare]) => throw UnsupportedError(\"Cannot mutate list from slice!\");\r\n\r\n  @override\r\n  Never sublist(int start, [int? end]) => throw UnsupportedError(\"Cannot take sublist from slice!\");\r\n\r\n  @override\r\n  Iterable<E> take(int count) sync* {\r\n    for (int i = start; i < start + count; ++i) {\r\n      yield list[i];\r\n    }\r\n  }\r\n\r\n  @override\r\n  Iterable<E> takeWhile(bool Function(E value) test) sync* {\r\n    for (int i = start; i < end; ++i) {\r\n      if (test(list[i])) {\r\n        yield list[i];\r\n      } else {\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  @override\r\n  List<E> toList({bool growable = true}) => list.sublist(start, end);\r\n\r\n  @override\r\n  Set<E> toSet() => <E>{for (int i = start; i < end; ++i) list[i]};\r\n\r\n  @override\r\n  String toString() {\r\n    StringBuffer buffer = StringBuffer();\r\n    buffer.write(\"&[\");\r\n    for (int i = start; i < end; ++i) {\r\n      if (i > start) {\r\n        buffer.write(\", \");\r\n      }\r\n      buffer.write(list[i]);\r\n    }\r\n    buffer.write(\"]\");\r\n    return buffer.toString();\r\n  }\r\n\r\n  @override\r\n  Iterable<E> where(bool Function(E element) test) sync* {\r\n    for (int i = start; i < end; ++i) {\r\n      if (test(list[i])) {\r\n        yield list[i];\r\n      }\r\n    }\r\n  }\r\n\r\n  @override\r\n  Iterable<T> whereType<T>() sync* {\r\n    for (int i = start; i < end; ++i) {\r\n      E value = list[i];\r\n\r\n      if (value is T) {\r\n        yield value;\r\n      }\r\n    }\r\n  }\r\n}\r\n"
        }
    ]
}