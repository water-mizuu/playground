{
    "sourceFile": "bin/math/numbers/quaternion.dart",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1698396701365,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1698396701364,
            "name": "Commit-0",
            "content": "import \"../functions/real_math.dart\" as rmath;\r\nimport \"../matrix.dart\";\r\n\r\nclass Quaternion extends NumberLike<Quaternion> {\r\n  static const Quaternion zero = Quaternion(0, 0, 0, 0);\r\n  static const Quaternion one = Quaternion(1, 0, 0, 0);\r\n  static const Quaternion two = Quaternion(2, 0, 0, 0);\r\n  static const Quaternion nan = Quaternion(double.nan, double.nan, double.nan, double.nan);\r\n\r\n  static Quaternion rotate(Quaternion vector, Quaternion axis, num angle) {\r\n    Quaternion normalizedAxis = axis.normalize();\r\n    Quaternion rotationQuaternion = rmath.cos(angle / 2).w + rmath.sin(angle / 2).w * normalizedAxis;\r\n    Quaternion inverseQuaternion = rmath.cos(-angle / 2).w + rmath.sin(-angle / 2).w * normalizedAxis;\r\n\r\n    return rotationQuaternion * (vector * inverseQuaternion);\r\n  }\r\n\r\n  final ComplexMember real;\r\n  final ComplexMember imaginaryI;\r\n  final ComplexMember imaginaryJ;\r\n  final ComplexMember imaginaryK;\r\n\r\n  const Quaternion(this.real, this.imaginaryI, this.imaginaryJ, this.imaginaryK);\r\n  const Quaternion.from(this.real)\r\n      : imaginaryI = 0,\r\n        imaginaryJ = 0,\r\n        imaginaryK = 0;\r\n  const Quaternion.imaginaryIFrom(this.imaginaryI)\r\n      : real = 0,\r\n        imaginaryJ = 0,\r\n        imaginaryK = 0;\r\n  const Quaternion.imaginaryJFrom(this.imaginaryJ)\r\n      : real = 0,\r\n        imaginaryI = 0,\r\n        imaginaryK = 0;\r\n  const Quaternion.imaginaryKFrom(this.imaginaryK)\r\n      : real = 0,\r\n        imaginaryI = 0,\r\n        imaginaryJ = 0;\r\n\r\n  ComplexMember imaginaryAbsSquared() => imaginaryI * imaginaryI + imaginaryJ * imaginaryJ + imaginaryK * imaginaryK;\r\n  ComplexMember absSquared() => real * real + imaginaryAbsSquared();\r\n  ComplexMember get norm => absSquared().pow(0.5);\r\n  ComplexMember get vectorNorm => imaginaryAbsSquared().pow(0.5);\r\n\r\n  @override\r\n  Quaternion abs() => norm.q;\r\n\r\n  @override\r\n  Quaternion add(Quaternion other) {\r\n    ComplexMember real = this.real + other.real;\r\n    ComplexMember imaginaryI = this.imaginaryI + other.imaginaryI;\r\n    ComplexMember imaginaryJ = this.imaginaryJ + other.imaginaryJ;\r\n    ComplexMember imaginaryK = this.imaginaryK + other.imaginaryK;\r\n\r\n    return Quaternion(real, imaginaryI, imaginaryJ, imaginaryK);\r\n  }\r\n\r\n  @override\r\n  Quaternion get additiveInverse => Quaternion(-real, -imaginaryI, -imaginaryJ, -imaginaryK);\r\n\r\n  @override\r\n  Quaternion ceil() => Quaternion(real.ceil(), imaginaryI.ceil(), imaginaryJ.ceil(), imaginaryK.ceil());\r\n\r\n  @override\r\n  Quaternion collapse() => Quaternion(\r\n        real.collapsed,\r\n        imaginaryI.collapsed,\r\n        imaginaryJ.collapsed,\r\n        imaginaryK.collapsed,\r\n      );\r\n\r\n  @override\r\n  Quaternion get collapsed => collapse();\r\n\r\n  @override\r\n  int compareTo(Quaternion other) => projection.compareTo(other.projection);\r\n\r\n  Quaternion get conjugate => Quaternion(real, -imaginaryI, -imaginaryJ, -imaginaryK);\r\n\r\n  @override\r\n  Quaternion divide(Quaternion other) {\r\n    Quaternion otherConjugate = Quaternion(other.real, -other.imaginaryI, -other.imaginaryJ, -other.imaginaryK);\r\n\r\n    ComplexMember otherAbs = absSquared();\r\n    ComplexMember conjugateReal = otherConjugate.real / otherAbs;\r\n    ComplexMember conjugateImaginaryI = otherConjugate.imaginaryI / otherAbs;\r\n    ComplexMember conjugateImaginaryJ = otherConjugate.imaginaryJ / otherAbs;\r\n    ComplexMember conjugateImaginaryK = otherConjugate.imaginaryK / otherAbs;\r\n\r\n    Quaternion otherMultiplicativeInverse = Quaternion(\r\n      conjugateReal,\r\n      conjugateImaginaryI,\r\n      conjugateImaginaryJ,\r\n      conjugateImaginaryK,\r\n    );\r\n\r\n    ComplexMember a1 = this.real;\r\n    ComplexMember a2 = otherMultiplicativeInverse.real;\r\n    ComplexMember b1 = this.imaginaryI;\r\n    ComplexMember b2 = otherMultiplicativeInverse.imaginaryI;\r\n    ComplexMember c1 = this.imaginaryJ;\r\n    ComplexMember c2 = otherMultiplicativeInverse.imaginaryJ;\r\n    ComplexMember d1 = this.imaginaryK;\r\n    ComplexMember d2 = otherMultiplicativeInverse.imaginaryK;\r\n\r\n    ComplexMember real = a1 * a2 - b1 * b2 - c1 * c2 - d1 * d2;\r\n    ComplexMember imaginaryI = a1 * b2 + b1 * a2 + c1 * d2 - d1 * c2;\r\n    ComplexMember imaginaryJ = a1 * c2 - b1 * d2 + c1 * a2 + d1 * b2;\r\n    ComplexMember imaginaryK = a1 * d2 + b1 * c2 - c1 * b2 + d1 * a2;\r\n\r\n    return Quaternion(real, imaginaryI, imaginaryJ, imaginaryK);\r\n    // return this * other.multiplicativeInverse;\r\n  }\r\n\r\n  @override\r\n  Quaternion floor() => Quaternion(real.floor(), imaginaryI.floor(), imaginaryJ.floor(), imaginaryK.floor());\r\n\r\n  @override\r\n  Quaternion floorDivide(Quaternion other) => divide(other).floor();\r\n\r\n  @override\r\n  bool isEqualTo(Quaternion other) =>\r\n      real == other.real &&\r\n      imaginaryI == other.imaginaryI &&\r\n      imaginaryJ == other.imaginaryJ &&\r\n      imaginaryK == other.imaginaryK;\r\n\r\n  @override\r\n  bool get isNaN => real.isNaN || imaginaryI.isNaN || imaginaryJ.isNaN || imaginaryK.isNaN;\r\n\r\n  @override\r\n  Quaternion modulo(Quaternion other) {\r\n    return this + other * (-this / other).ceil();\r\n  }\r\n\r\n  @override\r\n  // q^-1 = q'/(q*q')\r\n  //      = q'/|q|\r\n  Quaternion get multiplicativeInverse {\r\n    Quaternion conjugate = this.conjugate;\r\n\r\n    ComplexMember abs = absSquared();\r\n    ComplexMember real = conjugate.real / abs;\r\n    ComplexMember imaginaryI = conjugate.imaginaryI / abs;\r\n    ComplexMember imaginaryJ = conjugate.imaginaryJ / abs;\r\n    ComplexMember imaginaryK = conjugate.imaginaryK / abs;\r\n\r\n    return Quaternion(real, imaginaryI, imaginaryJ, imaginaryK);\r\n  }\r\n\r\n  @override\r\n  Quaternion multiply(Quaternion other) {\r\n    ComplexMember a1 = this.real;\r\n    ComplexMember a2 = other.real;\r\n    ComplexMember b1 = this.imaginaryI;\r\n    ComplexMember b2 = other.imaginaryI;\r\n    ComplexMember c1 = this.imaginaryJ;\r\n    ComplexMember c2 = other.imaginaryJ;\r\n    ComplexMember d1 = this.imaginaryK;\r\n    ComplexMember d2 = other.imaginaryK;\r\n\r\n    ComplexMember real = a1 * a2 - b1 * b2 - c1 * c2 - d1 * d2;\r\n    ComplexMember imaginaryI = a1 * b2 + b1 * a2 + c1 * d2 - d1 * c2;\r\n    ComplexMember imaginaryJ = a1 * c2 - b1 * d2 + c1 * a2 + d1 * b2;\r\n    ComplexMember imaginaryK = a1 * d2 + b1 * c2 - c1 * b2 + d1 * a2;\r\n\r\n    return Quaternion(real, imaginaryI, imaginaryJ, imaginaryK);\r\n  }\r\n\r\n  @override\r\n  Quaternion normalize() {\r\n    num magnitude = abs().real;\r\n\r\n    return Quaternion(\r\n      real / magnitude,\r\n      imaginaryI / magnitude,\r\n      imaginaryJ / magnitude,\r\n      imaginaryK / magnitude,\r\n    );\r\n  }\r\n\r\n  @override\r\n  Quaternion get normalized => normalize();\r\n\r\n  ComplexMember get projection => abs().real * real.sign;\r\n\r\n  @override\r\n  Quaternion pow(Quaternion other) {\r\n    throw UnimplementedError();\r\n  }\r\n\r\n  @override\r\n  Quaternion round() => Quaternion(real.round(), imaginaryI.round(), imaginaryJ.round(), imaginaryK.round());\r\n\r\n  @override\r\n  Quaternion get sign => this / abs();\r\n\r\n  String _writeToString(String Function(ComplexMember) function) {\r\n    StringBuffer buffer = StringBuffer();\r\n    ComplexMember absW = real * real.sign;\r\n    ComplexMember absI = imaginaryI * imaginaryI.sign;\r\n    ComplexMember absJ = imaginaryJ * imaginaryJ.sign;\r\n    ComplexMember absK = imaginaryK * imaginaryK.sign;\r\n\r\n    if (absW > 0) {\r\n      buffer\r\n        ..write((real < 0) ? \" - \" : \"\")\r\n        ..write(function(absW));\r\n    }\r\n    if (absI > 0) {\r\n      buffer\r\n        ..write(buffer.isNotEmpty ? (imaginaryI < 0 ? \" - \" : \" + \") : (imaginaryI < 0 ? \"-\" : \"\"))\r\n        ..write(function(absI))\r\n        ..write(\" i\");\r\n    }\r\n    if (absJ > 0) {\r\n      buffer\r\n        ..write(buffer.isNotEmpty ? (imaginaryJ < 0 ? \" - \" : \" + \") : (imaginaryJ < 0 ? \"-\" : \"\"))\r\n        ..write(function(absJ))\r\n        ..write(\" j\");\r\n    }\r\n    if (absK > 0) {\r\n      buffer\r\n        ..write(buffer.isNotEmpty ? (imaginaryK < 0 ? \" - \" : \" + \") : (imaginaryK < 0 ? \"-\" : \"\"))\r\n        ..write(function(absK))\r\n        ..write(\" k\");\r\n    }\r\n\r\n    if (buffer.isEmpty) {\r\n      return function(0);\r\n    }\r\n\r\n    return buffer.toString();\r\n  }\r\n\r\n  @override\r\n  String get str => _writeToString((ComplexMember v) => v.toString());\r\n\r\n  @override\r\n  String get strLong => collapsed._writeToString((ComplexMember v) => v.strLong);\r\n\r\n  @override\r\n  String get strRat => collapsed._writeToString((ComplexMember v) => v.strRat);\r\n\r\n  @override\r\n  String get strShort => collapsed._writeToString((ComplexMember v) => v.strShort);\r\n\r\n  @override\r\n  Quaternion subtract(Quaternion other) {\r\n    ComplexMember real = this.real - other.real;\r\n    ComplexMember imaginaryI = this.imaginaryI - other.imaginaryI;\r\n    ComplexMember imaginaryJ = this.imaginaryJ - other.imaginaryJ;\r\n    ComplexMember imaginaryK = this.imaginaryK - other.imaginaryK;\r\n\r\n    return Quaternion(real, imaginaryI, imaginaryJ, imaginaryK);\r\n  }\r\n}\r\n\r\nextension QuaternionNumExtension on ComplexMember {\r\n  Quaternion get q => Quaternion.from(this);\r\n  Quaternion get qi => Quaternion.imaginaryIFrom(this);\r\n  Quaternion get qj => Quaternion.imaginaryJFrom(this);\r\n  Quaternion get qk => Quaternion.imaginaryKFrom(this);\r\n\r\n  Quaternion get qre => q;\r\n  Quaternion get imI => qi;\r\n  Quaternion get imJ => qj;\r\n  Quaternion get imK => qk;\r\n\r\n  Quaternion get w => q;\r\n  Quaternion get vi => qi;\r\n  Quaternion get vj => qj;\r\n  Quaternion get vk => qk;\r\n}\r\n"
        }
    ]
}