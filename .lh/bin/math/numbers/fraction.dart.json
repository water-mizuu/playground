{
    "sourceFile": "bin/math/numbers/fraction.dart",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1698396685136,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1698396685136,
            "name": "Commit-0",
            "content": "import \"dart:math\" as math;\r\n\r\nimport \"number_like.dart\";\r\n\r\npart \"../parts/numbers/fraction/fraction_nan.dart\";\r\n\r\nclass Fraction extends NumberLike<Fraction> {\r\n  static final Fraction zero = Fraction(BigInt.zero);\r\n  static final Fraction one = Fraction(BigInt.one);\r\n  static final Fraction two = Fraction(BigInt.two);\r\n  static final Fraction nan = _NotAFraction();\r\n\r\n  static BigInt _euclidGcf(BigInt big, BigInt small) {\r\n    BigInt b = big;\r\n    BigInt s = small;\r\n\r\n    while (s != BigInt.zero) {\r\n      BigInt temp = s;\r\n      s = b % s;\r\n      b = temp;\r\n    }\r\n    return b;\r\n  }\r\n\r\n  static BigInt _computeGcf(BigInt left, BigInt right) {\r\n    if (left == BigInt.zero && right == BigInt.zero) {\r\n      return BigInt.one;\r\n    }\r\n\r\n    BigInt leftAbs = left.abs();\r\n    BigInt rightAbs = right.abs();\r\n\r\n    BigInt big = leftAbs > rightAbs ? leftAbs : rightAbs;\r\n    BigInt small = leftAbs > rightAbs ? rightAbs : leftAbs;\r\n\r\n    return _euclidGcf(big, small);\r\n  }\r\n\r\n  final BigInt numerator;\r\n  final BigInt denominator;\r\n\r\n  factory Fraction(BigInt numerator, [BigInt? denominator]) {\r\n    denominator ??= BigInt.one;\r\n\r\n    if (denominator == BigInt.zero) {\r\n      return Fraction.nan;\r\n    }\r\n\r\n    BigInt gcf = _computeGcf(numerator, denominator);\r\n\r\n    return Fraction._(numerator ~/ gcf, denominator ~/ gcf);\r\n  }\r\n  factory Fraction.fromInts(int numerator, [int denominator = 1]) => Fraction._(numerator.n, denominator.n);\r\n  factory Fraction.from(num value, [num error = 1e-9]) {\r\n    int base = value.floor();\r\n    num decimal = value - base;\r\n\r\n    if (decimal < error) {\r\n      return Fraction.fromInts(base);\r\n    } else if (1 - error < decimal) {\r\n      return Fraction.fromInts(base + 1);\r\n    }\r\n\r\n    int lowerN = 0;\r\n    int lowerD = 1;\r\n    int upperN = 1;\r\n    int upperD = 1;\r\n    for (;;) {\r\n      int middleN = lowerN + upperN;\r\n      int middleD = lowerD + upperD;\r\n\r\n      if (middleD * (decimal + error) < middleN) {\r\n        upperN = middleN;\r\n        upperD = middleD;\r\n      } else if (middleN < (decimal - error) * middleD) {\r\n        lowerN = middleN;\r\n        lowerD = middleD;\r\n      } else {\r\n        return Fraction.fromInts(base * middleD + middleN, middleD);\r\n      }\r\n    }\r\n  }\r\n  const Fraction._(this.numerator, this.denominator);\r\n\r\n  @override\r\n  Fraction abs() {\r\n    BigInt numerator = this.numerator.abs();\r\n    BigInt denominator = this.denominator.abs();\r\n\r\n    return Fraction(numerator, denominator);\r\n  }\r\n\r\n  @override\r\n  Fraction add(Fraction other) {\r\n    /// (a / b) + (c / d) = (ad + bc) / (cd)\r\n\r\n    BigInt numerator = this.numerator * other.denominator + other.numerator * this.denominator;\r\n    BigInt denominator = this.denominator * other.denominator;\r\n\r\n    return Fraction(numerator, denominator);\r\n  }\r\n\r\n  @override\r\n  Fraction get additiveInverse => Fraction(-numerator, denominator);\r\n\r\n  @override\r\n  Fraction ceil() {\r\n    BigInt remainder = this.numerator.remainder(this.denominator);\r\n    BigInt decimal = (remainder / this.denominator).ceil().toBigInt();\r\n\r\n    BigInt numerator = decimal + this.numerator ~/ this.denominator;\r\n    BigInt denominator = 1.n;\r\n\r\n    return Fraction(numerator, denominator);\r\n  }\r\n\r\n  @override\r\n  Fraction collapse() {\r\n    const double _threshold = 1000000000;\r\n    BigInt threshold = _threshold.n;\r\n    // If the numbers get too large, be willing to lose some accuracy.\r\n\r\n    if (this.numerator.abs() < threshold || this.denominator.abs() < threshold) {\r\n      return this;\r\n    }\r\n\r\n    BigInt numerator = this.numerator.abs();\r\n    BigInt denominator = this.denominator.abs();\r\n    while (numerator.abs() >= threshold || denominator.abs() >= threshold) {\r\n      numerator = (numerator ~/ threshold) + (numerator.remainder(threshold) == 0.n ? 1.n : 0.n);\r\n      denominator = (denominator ~/ threshold) + (denominator.remainder(threshold) == 0.n ? 1.n : 0.n);\r\n    }\r\n\r\n    return Fraction(numerator, denominator);\r\n  }\r\n\r\n  @override\r\n  Fraction get collapsed => collapse();\r\n\r\n  @override\r\n  int compareTo(Fraction other) {\r\n    /// Normally it should be compared by the difference of the fractions.\r\n    /// i.e compare(a / b , c / d) = (ad - bc)/(bd).\r\n    /// However, only the sign matters, so we can discard the product denominator `bd`.\r\n\r\n    return (numerator * other.denominator - other.numerator * denominator).toInt();\r\n  }\r\n\r\n  @override\r\n  Fraction divide(Fraction other) {\r\n    /// (a / b) รท (c / d) = ad / bc\r\n\r\n    BigInt numerator = this.numerator * other.denominator;\r\n    BigInt denominator = this.denominator * other.numerator;\r\n\r\n    return Fraction(numerator, denominator);\r\n  }\r\n\r\n  @override\r\n  Fraction floor() {\r\n    BigInt remainder = this.numerator.remainder(this.denominator);\r\n    BigInt decimal = (remainder / this.denominator).floor().toBigInt();\r\n\r\n    BigInt numerator = decimal + this.numerator ~/ this.denominator;\r\n    BigInt denominator = 1.n;\r\n\r\n    return Fraction(numerator, denominator);\r\n  }\r\n\r\n  @override\r\n  Fraction floorDivide(Fraction other) {\r\n    /// (a / b) รท (c / d) = ad / bc\r\n\r\n    BigInt numerator = this.numerator * other.denominator;\r\n    BigInt denominator = this.denominator * other.numerator;\r\n\r\n    return Fraction(numerator ~/ denominator, 1.n);\r\n  }\r\n\r\n  @override\r\n  bool isEqualTo(Fraction other) => numerator == other.numerator && denominator == other.denominator;\r\n\r\n  @override\r\n  bool get isNaN => false;\r\n\r\n  @override\r\n  Fraction modulo(Fraction other) {\r\n    /// x % 0 = x\r\n    /// x % y = x - y * floor(x / y)\r\n\r\n    if (other.reduced == 0.f) {\r\n      return reduced;\r\n    }\r\n\r\n    return this - other * (this ~/ other);\r\n  }\r\n\r\n  @override\r\n  Fraction get multiplicativeInverse => denominator == 0.n //\r\n      ? throw StateError(\"Division by zero\")\r\n      : Fraction(denominator, numerator);\r\n\r\n  @override\r\n  Fraction multiply(Fraction other) {\r\n    /// (a / b) * (c / d) = ac / bd\r\n\r\n    BigInt numerator = this.numerator * other.numerator;\r\n    BigInt denominator = this.denominator * other.denominator;\r\n\r\n    return Fraction(numerator, denominator);\r\n  }\r\n\r\n  @override\r\n  Fraction normalize() => collapsed;\r\n\r\n  @override\r\n  Fraction get normalized => collapsed;\r\n\r\n  @override\r\n  Fraction pow(Fraction other) {\r\n    num result = math.pow(collapsed.value, other.collapsed.value);\r\n    if (result.isInfinite) {\r\n      throw Exception(\":< It's too large\");\r\n    }\r\n\r\n    return Fraction.from(result);\r\n  }\r\n\r\n  Fraction get reduced {\r\n    BigInt gcf = _computeGcf(numerator, denominator);\r\n    BigInt sign = denominator.isNegative ? -1.n : 1.n;\r\n\r\n    return Fraction(sign * numerator ~/ gcf, sign * denominator ~/ gcf);\r\n  }\r\n\r\n  BigInt get remainder => numerator.remainder(denominator);\r\n\r\n  @override\r\n  Fraction round() {\r\n    BigInt remainder = this.numerator.remainder(this.denominator);\r\n    BigInt decimal = (remainder / this.denominator).round().toBigInt();\r\n\r\n    BigInt numerator = decimal + this.numerator ~/ this.denominator;\r\n    BigInt denominator = 1.n;\r\n\r\n    return Fraction(numerator, denominator);\r\n  }\r\n\r\n  @override\r\n  Fraction get sign => value > 0 ? 1.f : -1.f;\r\n\r\n  @override\r\n  String get str => strRat;\r\n\r\n  @override\r\n  String get strLong => value.toStringAsFixed(12);\r\n\r\n  @override\r\n  String get strRat => denominator == 1.n ? \"$numerator\" : \"$numerator/$denominator\";\r\n\r\n  @override\r\n  String get strShort => value.toStringAsFixed(4);\r\n\r\n  int toInt() => truncated().toInt();\r\n\r\n  BigInt truncated() => numerator ~/ denominator;\r\n\r\n  @override\r\n  Fraction subtract(Fraction other) {\r\n    /// (a / b) - (c / d) = (ad - bc) / (cd)\r\n\r\n    BigInt numerator = this.numerator * other.denominator - other.numerator * this.denominator;\r\n    BigInt denominator = this.denominator * other.denominator;\r\n\r\n    return Fraction(numerator, denominator);\r\n  }\r\n\r\n  num get value {\r\n    if (numerator.bitLength < 128 && denominator.bitLength < 128) {\r\n      return numerator / denominator;\r\n    }\r\n\r\n    BigInt boost = 10.n.pow(64);\r\n    BigInt augmented = numerator * boost ~/ denominator;\r\n\r\n    return (augmented ~/ boost).toInt() + (augmented % boost) / boost;\r\n  }\r\n}\r\n\r\nextension BigIntNumExtension on num {\r\n  BigInt toBigInt() => BigInt.from(this);\r\n  BigInt get n => toBigInt();\r\n\r\n  Fraction toFraction() => Fraction.from(this);\r\n  Fraction get f => toFraction();\r\n}\r\n\r\nextension FractionBigIntExtension on BigInt {\r\n  Fraction toFraction() => Fraction(this, 1.n);\r\n  Fraction get f => toFraction();\r\n}\r\n"
        }
    ]
}