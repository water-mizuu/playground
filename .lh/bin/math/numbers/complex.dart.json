{
    "sourceFile": "bin/math/numbers/complex.dart",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1698396677941,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1698396677941,
            "name": "Commit-0",
            "content": "import \"../functions/complex_math.dart\" as c_math;\r\nimport \"../functions/real_math.dart\" as r_math;\r\nimport \"../shared.dart\";\r\n\r\nclass Complex extends NumberLike<Complex> {\r\n  static const Complex zero = Complex(0, 0);\r\n  static const Complex one = Complex(1, 0);\r\n  static const Complex two = Complex(2, 0);\r\n  static const Complex nan = Complex(double.nan, double.nan);\r\n\r\n  final ComplexMember real;\r\n  final ComplexMember imaginary;\r\n\r\n  const Complex(this.real, this.imaginary);\r\n  const Complex.fromNum(this.real, this.imaginary);\r\n  const Complex.from(this.real) : imaginary = 0;\r\n  const Complex.imaginaryFrom(this.imaginary) : real = 0;\r\n\r\n  // Knowing how fractions work, this seems like it'll be a nightmare. :(\r\n  ComplexMember absSquared() => real.pow(2) + imaginary.pow(2);\r\n\r\n  @override\r\n  Complex abs() => Complex(absSquared().pow(0.5), 0);\r\n\r\n  @override\r\n  Complex add(Complex other) => Complex(real + other.real, imaginary + other.imaginary);\r\n\r\n  @override\r\n  Complex get additiveInverse => Complex(-real, -imaginary);\r\n\r\n  num get argument => r_math.atan2(imaginary, real);\r\n\r\n  @override\r\n  Complex ceil() => Complex(real.ceil(), imaginary.ceil());\r\n\r\n  @override\r\n  Complex collapse() => collapsed;\r\n\r\n  @override\r\n  Complex get collapsed => Complex(real.collapsed, imaginary.collapsed);\r\n\r\n  @override\r\n  int compareTo(Complex other) => projection.compareTo(other.projection);\r\n\r\n  @override\r\n  Complex divide(Complex other) {\r\n    /// (a + bi)/(c + di)\r\n    ///   = (a + bi)(c - di)/(c² + d²)\r\n    ///   = (ac + bci - adi - bdi²)/(c² + d²)\r\n    ///   = (ac + bci - adi + bd)/(c² + d²)\r\n    ///   = [(ac + bd) + (bc - ad) i]/(c² + d²)\r\n    ///   = (ac + bd)/(c² + d²) + (bc - ad)/(c² + d²) i\r\n    ComplexMember denominator = other.real.pow(2) + other.imaginary.pow(2);\r\n    ComplexMember real = (this.real * other.real + this.imaginary * other.imaginary) / denominator;\r\n    ComplexMember imaginary = (this.imaginary * other.real - this.real * other.imaginary) / denominator;\r\n\r\n    return Complex(real, imaginary);\r\n  }\r\n\r\n  @override\r\n  Complex floor() => Complex(real.floor(), imaginary.floor());\r\n\r\n  @override\r\n  Complex floorDivide(Complex other) => divide(other).floor();\r\n\r\n  Complex get inverseConjugate => Complex(real, -imaginary);\r\n\r\n  @override\r\n  bool isEqualTo(Complex other) => real == other.real && imaginary == other.imaginary;\r\n\r\n  @override\r\n  bool get isNaN => real.isNaN || imaginary.isNaN;\r\n\r\n  @override\r\n  Complex modulo(Complex other) {\r\n    /// (a + bi) % (c + di)\r\n    ///     = (a + bi) + (c + di)⌈-(a + bi)/(c + di)⌉\r\n    ///     = α + β\r\n    /// α = this\r\n    /// β = other * ceil(-self/other)\r\n\r\n    return this + other * (-this / other).ceil();\r\n  }\r\n\r\n  @override\r\n  Complex get multiplicativeInverse {\r\n    ComplexMember denominator = this.real.pow(2) + this.imaginary.pow(2);\r\n    ComplexMember real = this.real / denominator;\r\n    ComplexMember imaginary = -(this.imaginary / denominator);\r\n\r\n    return Complex(real, imaginary);\r\n  }\r\n\r\n  @override\r\n  Complex multiply(Complex other) {\r\n    /// (a + bi)(c + di)\r\n    ///   = ac + bci + adi + bdi²\r\n    ///   = ac + bci + adi - bd\r\n    ///   = (ac - bd) + (ad + bc) i\r\n    ComplexMember real = this.real * other.real - this.imaginary * other.imaginary;\r\n    ComplexMember imaginary = this.real * other.imaginary + this.imaginary * other.real;\r\n\r\n    return Complex(real, imaginary);\r\n  }\r\n\r\n  @override\r\n  Complex normalize() => this;\r\n\r\n  @override\r\n  Complex get normalized => normalize();\r\n\r\n  @override\r\n  Complex pow(Complex other) => c_math.pow(this, other);\r\n\r\n  ComplexMember get projection => abs().real * real.sign;\r\n\r\n  @override\r\n  Complex round() => Complex(real.round(), imaginary.round());\r\n\r\n  @override\r\n  Complex get sign => this == 0.re ? 1.re : this / abs();\r\n\r\n  String _writeToString(String Function(ComplexMember) function) {\r\n    StringBuffer buffer = StringBuffer();\r\n    ComplexMember absW = real * real.sign;\r\n    ComplexMember absI = imaginary * imaginary.sign;\r\n\r\n    if (absW > 0) {\r\n      buffer\r\n        ..write(buffer.isNotEmpty ? (real < 0 ? \" - \" : \" + \") : (real < 0 ? \"-\" : \"\"))\r\n        ..write(function(absW));\r\n    }\r\n    if (absI > 0) {\r\n      buffer\r\n        ..write(buffer.isNotEmpty ? (imaginary < 0 ? \" - \" : \" + \") : (imaginary < 0 ? \"-\" : \"\"))\r\n        ..write(function(absI))\r\n        ..write(\" i\");\r\n    }\r\n\r\n    if (buffer.isEmpty) {\r\n      return function(0);\r\n    }\r\n\r\n    return buffer.toString();\r\n  }\r\n\r\n  @override\r\n  String get str => _writeToString((ComplexMember v) => v.toString());\r\n\r\n  @override\r\n  String get strLong => collapsed._writeToString((ComplexMember v) => v.strLong);\r\n\r\n  @override\r\n  String get strRat => collapsed._writeToString((ComplexMember v) => v.strRat);\r\n\r\n  @override\r\n  String get strShort => collapsed._writeToString((ComplexMember v) => v.strShort);\r\n\r\n  @override\r\n  Complex subtract(Complex other) => Complex(real - other.real, imaginary - other.imaginary);\r\n}\r\n\r\nextension ComplexNumExtension on num {\r\n  num pow(num exponent) => r_math.pow(this, exponent);\r\n  num fix([double error = 1e-9]) => rationalize(error).value;\r\n\r\n  num get collapsed => fix();\r\n  String get strLong => toStringAsFixed(16);\r\n  String get strShort => toStringAsFixed(4);\r\n  String get strRat => rationalized.strRat;\r\n\r\n  Fraction get rationalized => rationalize();\r\n  Fraction rationalize([double error = 1e-9]) {\r\n    if (isNaN) {\r\n      return Fraction(1.n, 0.n);\r\n    }\r\n\r\n    int base = floor();\r\n    num decimal = this - base;\r\n\r\n    if (decimal < error) {\r\n      return Fraction.fromInts(base);\r\n    } else if (1 - error < decimal) {\r\n      return Fraction.fromInts(base + 1);\r\n    }\r\n\r\n    int lowerN = 0;\r\n    int lowerD = 1;\r\n    int upperN = 1;\r\n    int upperD = 1;\r\n    for (;;) {\r\n      int middleN = lowerN + upperN;\r\n      int middleD = lowerD + upperD;\r\n\r\n      if (middleD * (decimal + error) < middleN) {\r\n        upperN = middleN;\r\n        upperD = middleD;\r\n      } else if (middleN < (decimal - error) * middleD) {\r\n        lowerN = middleN;\r\n        lowerD = middleD;\r\n      } else {\r\n        return Fraction.fromInts(base * middleD + middleN, middleD);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nextension ComplexFractionExtension on ComplexMember {\r\n  Complex get c => Complex.from(this);\r\n  Complex get ci => Complex.imaginaryFrom(this);\r\n\r\n  Complex get re => c;\r\n  Complex get im => ci;\r\n}\r\n"
        }
    ]
}