{
    "sourceFile": "bin/math/matrix.dart",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 1,
            "patches": [
                {
                    "date": 1698396659290,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1700007400393,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -15,10 +15,8 @@\n \r\n enum VerticalDirection { up, down }\r\n \r\n class Matrix<E> extends Iterable<E> {\r\n-  final List<List<E>> data;\r\n-\r\n   const Matrix(this.data);\r\n   factory Matrix.fromVectors(List<Vector<E>> columnVectors) {\r\n     Set<int> degrees = columnVectors.map((Vector<E> v) => v.degree).toSet();\r\n     if (degrees.length > 1) {\r\n@@ -31,8 +29,9 @@\n     ];\r\n \r\n     return Matrix<E>(data);\r\n   }\r\n+  final List<List<E>> data;\r\n \r\n   Iterable<E> get _iterable sync* {\r\n     for (List<E> row in data) {\r\n       yield* row;\r\n@@ -50,9 +49,9 @@\n         <E>[\r\n           if (left != null) ...left.data[y],\r\n           ...data[y],\r\n           if (right != null) ...right.data[y],\r\n-        ]\r\n+        ],\r\n     ]);\r\n   }\r\n \r\n   Matrix<E> verticalConcatenate({Matrix<E>? up, Matrix<E>? down}) {\r\n@@ -70,24 +69,24 @@\n \r\n   Matrix<E> submatrix({int top = 0, int bottom = 0, int left = 0, int right = 0}) => //\r\n       Matrix<E>(<List<E>>[\r\n         for (int y = top; y < data.length - bottom; y++)\r\n-          <E>[for (int x = left; x < data[y].length - right; x++) data[y][x]]\r\n+          <E>[for (int x = left; x < data[y].length - right; x++) data[y][x]],\r\n       ]);\r\n \r\n   Matrix<E> removed({Set<int> x = const <int>{}, Set<int> y = const <int>{}}) => //\r\n       Matrix<E>(<List<E>>[\r\n-        for (int _y = 0; _y < verticalLength; _y++)\r\n-          if (!y.contains(_y))\r\n+        for (int yi = 0; yi < verticalLength; yi++)\r\n+          if (!y.contains(yi))\r\n             <E>[\r\n-              for (int _x = 0; _x < horizontalLength; _x++)\r\n-                if (!x.contains(_x)) data[_y][_x]\r\n-            ]\r\n+              for (int xi = 0; xi < horizontalLength; xi++)\r\n+                if (!x.contains(xi)) data[yi][xi],\r\n+            ],\r\n       ]);\r\n \r\n   Matrix<E> transpose() => Matrix<E>(<List<E>>[\r\n         for (int x = 0; x < horizontalLength; x++) //\r\n-          <E>[for (int y = 0; y < verticalLength; y++) data[y][x]]\r\n+          <E>[for (int y = 0; y < verticalLength; y++) data[y][x]],\r\n       ]);\r\n \r\n   Matrix<E> expandColumn(\r\n     int at,\r\n@@ -108,17 +107,17 @@\n           if (filler != null && direction == HorizontalDirection.left)\r\n             for (int x = row.length; x < max; x++) filler,\r\n           ...row,\r\n           if (filler != null && direction == HorizontalDirection.right)\r\n-            for (int x = row.length; x < max; x++) filler\r\n-        ]\r\n+            for (int x = row.length; x < max; x++) filler,\r\n+        ],\r\n     ];\r\n     _List2d<E> matrix = <List<E>>[\r\n       for (int y = 0; y < data.length; y++)\r\n         <E>[\r\n           for (int x = 0; x < data[y].length; x++)\r\n-            if (x == at) ...filled[y] else data[y][x]\r\n-        ]\r\n+            if (x == at) ...filled[y] else data[y][x],\r\n+        ],\r\n     ];\r\n \r\n     return Matrix<E>(matrix);\r\n   }\r\n@@ -165,11 +164,11 @@\n     _List2d<E> built = <List<E>>[\r\n       for (int y = 0; y < verticalLength; ++y)\r\n         if (y == at) //\r\n           ...<List<E>>[\r\n-          for (int _y = 0; _y < max; ++_y) <E>[for (int x = 0; x < horizontalLength; ++x) normalized[x][_y]]\r\n+          for (int y = 0; y < max; ++y) <E>[for (int x = 0; x < horizontalLength; ++x) normalized[x][y]],\r\n         ] else\r\n-          data[y]\r\n+          data[y],\r\n     ];\r\n \r\n     return Matrix<E>(built);\r\n   }\r\n@@ -177,29 +176,29 @@\n   Matrix<E> mapColumn(int index, E Function(E element) handler) => Matrix<E>(<List<E>>[\r\n         for (List<E> row in data)\r\n           <E>[\r\n             for (int i = 0; i < row.length; i++)\r\n-              if (i == index) handler(row[i]) else row[i]\r\n+              if (i == index) handler(row[i]) else row[i],\r\n           ],\r\n       ]);\r\n \r\n   Matrix<E> mapRow<R extends E>(int index, E Function(E element) handler) => Matrix<E>(<List<E>>[\r\n         for (int i = 0; i < data.length; i++)\r\n           <E>[\r\n             for (E item in data[i])\r\n-              if (i == index) handler(item) else item\r\n+              if (i == index) handler(item) else item,\r\n           ],\r\n       ]);\r\n \r\n   Matrix<R> matrixMap<R>(R Function(E element) handler) => Matrix<R>(<List<R>>[\r\n-        for (List<E> row in data) <R>[for (E item in row) handler(item)]\r\n+        for (List<E> row in data) <R>[for (E item in row) handler(item)],\r\n       ]);\r\n \r\n   bool matrixAny(bool Function(E element) handler) => data.any((List<E> row) => row.any(handler));\r\n   bool matrixEvery(bool Function(E element) handler) => data.every((List<E> row) => row.every(handler));\r\n \r\n   Matrix<E> copy() => Matrix<E>(<List<E>>[\r\n-        for (List<E> row in data) <E>[for (E item in row) item]\r\n+        for (List<E> row in data) <E>[for (E item in row) item],\r\n       ]);\r\n \r\n   int get verticalLength => data.length;\r\n   int get horizontalLength => _safeLength;\r\n@@ -245,9 +244,9 @@\n     if (matrixAny((E v) => v is! NumberLike)) {\r\n       throw TypeError();\r\n     }\r\n \r\n-    Matrix<String> stringified = matrixMap((E v) => (v as NumberLike<void>).strShort);\r\n+    Matrix<String> stringified = matrixMap((E v) => (v as NumberLike<void>)..);\r\n \r\n     return _buildString(stringified);\r\n   }\r\n \r\n@@ -343,21 +342,21 @@\n   }\r\n \r\n   List<Vector<E>> get rowVectors => _ListVectorProxy<E>(this, <List<(int, int)>>[\r\n         for (int y = 0; y < verticalLength; ++y) //\r\n-          <(int, int)>[for (int x = 0; x < horizontalLength; ++x) (y, x)]\r\n+          <(int, int)>[for (int x = 0; x < horizontalLength; ++x) (y, x)],\r\n       ]);\r\n   List<Vector<E>> get columnVectors => _ListVectorProxy<E>(this, <List<(int, int)>>[\r\n         for (int x = 0; x < horizontalLength; ++x) //\r\n-          <(int, int)>[for (int y = 0; y < verticalLength; ++y) (y, x)]\r\n+          <(int, int)>[for (int y = 0; y < verticalLength; ++y) (y, x)],\r\n       ]);\r\n   List<Vector<E>> get rightDiagonalVectors => _ListVectorProxy<E>(this, <List<(int, int)>>[\r\n         for (int x = 0; x < horizontalLength; ++x) //\r\n-          <(int, int)>[for (int y = 0; y < verticalLength; ++y) (y, (y + x) % horizontalLength)]\r\n+          <(int, int)>[for (int y = 0; y < verticalLength; ++y) (y, (y + x) % horizontalLength)],\r\n       ]);\r\n   List<Vector<E>> get leftDiagonalVectors => _ListVectorProxy<E>(this, <List<(int, int)>>[\r\n         for (int x = 0; x < horizontalLength; ++x) //\r\n-          <(int, int)>[for (int y = 0; y < verticalLength; ++y) (y, (horizontalLength + y - x) % horizontalLength)]\r\n+          <(int, int)>[for (int y = 0; y < verticalLength; ++y) (y, (horizontalLength + y - x) % horizontalLength)],\r\n       ]);\r\n   Vector<E> operator [](int index) => Vector<E>(data[index]);\r\n   void operator []=(int index, Vector<E> val) => data[index] = val.data;\r\n \r\n"
                }
            ],
            "date": 1698396659290,
            "name": "Commit-0",
            "content": "import \"dart:math\" as r_math;\r\n\r\nimport \"functions/complex_math.dart\" as c_math;\r\nimport \"shared.dart\";\r\n\r\nexport \"shared.dart\";\r\n\r\npart \"parts/matrix/element_wise.dart\";\r\npart \"parts/matrix/list_vector_proxy.dart\";\r\npart \"parts/matrix/numerical_matrix.dart\";\r\n\r\ntypedef _List2d<E> = List<List<E>>;\r\n\r\nenum HorizontalDirection { left, right }\r\n\r\nenum VerticalDirection { up, down }\r\n\r\nclass Matrix<E> extends Iterable<E> {\r\n  final List<List<E>> data;\r\n\r\n  const Matrix(this.data);\r\n  factory Matrix.fromVectors(List<Vector<E>> columnVectors) {\r\n    Set<int> degrees = columnVectors.map((Vector<E> v) => v.degree).toSet();\r\n    if (degrees.length > 1) {\r\n      throw StateError(\"Cannot create a matrix with inconsistent degrees!\");\r\n    }\r\n    int height = degrees.min();\r\n    List<List<E>> data = <List<E>>[\r\n      for (int y = 0; y < height; ++y) //\r\n        <E>[for (int x = 0; x < columnVectors.length; ++x) columnVectors[x][y]],\r\n    ];\r\n\r\n    return Matrix<E>(data);\r\n  }\r\n\r\n  Iterable<E> get _iterable sync* {\r\n    for (List<E> row in data) {\r\n      yield* row;\r\n    }\r\n  }\r\n\r\n  Matrix<E> horizontalConcatenate({Matrix<E>? left, Matrix<E>? right}) {\r\n    if ((left?.verticalLength ?? verticalLength) != verticalLength ||\r\n        (right?.verticalLength ?? verticalLength) != verticalLength) {\r\n      throw StateError(\"in horzcat, the matrices must have matching vertical dimensions!\");\r\n    }\r\n\r\n    return Matrix<E>(<List<E>>[\r\n      for (int y = 0; y < verticalLength; ++y)\r\n        <E>[\r\n          if (left != null) ...left.data[y],\r\n          ...data[y],\r\n          if (right != null) ...right.data[y],\r\n        ]\r\n    ]);\r\n  }\r\n\r\n  Matrix<E> verticalConcatenate({Matrix<E>? up, Matrix<E>? down}) {\r\n    if ((up?.horizontalLength ?? horizontalLength) != horizontalLength ||\r\n        (down?.horizontalLength ?? horizontalLength) != horizontalLength) {\r\n      throw StateError(\"in vrtcat, the matrices must have matching horizontal dimensions!\");\r\n    }\r\n\r\n    return Matrix<E>(<List<E>>[\r\n      if (up != null) ...up.data,\r\n      ...this.data,\r\n      if (down != null) ...down.data,\r\n    ]);\r\n  }\r\n\r\n  Matrix<E> submatrix({int top = 0, int bottom = 0, int left = 0, int right = 0}) => //\r\n      Matrix<E>(<List<E>>[\r\n        for (int y = top; y < data.length - bottom; y++)\r\n          <E>[for (int x = left; x < data[y].length - right; x++) data[y][x]]\r\n      ]);\r\n\r\n  Matrix<E> removed({Set<int> x = const <int>{}, Set<int> y = const <int>{}}) => //\r\n      Matrix<E>(<List<E>>[\r\n        for (int _y = 0; _y < verticalLength; _y++)\r\n          if (!y.contains(_y))\r\n            <E>[\r\n              for (int _x = 0; _x < horizontalLength; _x++)\r\n                if (!x.contains(_x)) data[_y][_x]\r\n            ]\r\n      ]);\r\n\r\n  Matrix<E> transpose() => Matrix<E>(<List<E>>[\r\n        for (int x = 0; x < horizontalLength; x++) //\r\n          <E>[for (int y = 0; y < verticalLength; y++) data[y][x]]\r\n      ]);\r\n\r\n  Matrix<E> expandColumn(\r\n    int at,\r\n    List<E> Function(E element) handler, {\r\n    E? filler,\r\n    HorizontalDirection direction = HorizontalDirection.right,\r\n  }) {\r\n    _List2d<E> expanded = <List<E>>[for (int y = 0; y < data.length; y++) handler(data[y][at])];\r\n    Set<int> resultLengths = expanded.map((List<E> list) => list.length).toSet();\r\n    if (filler == null && resultLengths.length > 1) {\r\n      throw StateError(\"The resulting matrix shape is uneven and there was no filler provided.\");\r\n    }\r\n\r\n    int max = resultLengths.max();\r\n    _List2d<E> filled = <List<E>>[\r\n      for (List<E> row in expanded)\r\n        <E>[\r\n          if (filler != null && direction == HorizontalDirection.left)\r\n            for (int x = row.length; x < max; x++) filler,\r\n          ...row,\r\n          if (filler != null && direction == HorizontalDirection.right)\r\n            for (int x = row.length; x < max; x++) filler\r\n        ]\r\n    ];\r\n    _List2d<E> matrix = <List<E>>[\r\n      for (int y = 0; y < data.length; y++)\r\n        <E>[\r\n          for (int x = 0; x < data[y].length; x++)\r\n            if (x == at) ...filled[y] else data[y][x]\r\n        ]\r\n    ];\r\n\r\n    return Matrix<E>(matrix);\r\n  }\r\n\r\n  Matrix<E> expandRow(\r\n    int at,\r\n    List<E> Function(E element) handler, {\r\n    E? filler,\r\n    VerticalDirection direction = VerticalDirection.down,\r\n  }) {\r\n    /// Build the matrix.\r\n    /// if y == index, expand bottom.\r\n    ///\r\n    _List2d<E> expanded = <List<E>>[for (int x = 0; x < horizontalLength; ++x) handler(data[at][x])];\r\n    Set<int> resultLengths = expanded.map((List<E> list) => list.length).toSet();\r\n    if (filler == null && resultLengths.length > 1) {\r\n      throw StateError(\"The resulting matrix shape is uneven and there was no filler provided.\");\r\n    }\r\n\r\n    /// Normalize the matrix.\r\n    ///   If the shape is consistent, let it be.\r\n    ///   Else, we pad it with the filler.\r\n    int max = resultLengths.max();\r\n    _List2d<E> normalized = <List<E>>[\r\n      for (List<E> partialColumn in expanded)\r\n        if (partialColumn.length == max)\r\n          partialColumn\r\n        else\r\n          <E>[\r\n            /// Dichotomy states that it can only be UP or DOWN.\r\n            ///   For the extra null check, idk.\r\n            if (filler != null && direction == VerticalDirection.up)\r\n              for (int i = partialColumn.length; i < max; ++i) filler,\r\n            ...partialColumn,\r\n            if (filler != null && direction == VerticalDirection.down)\r\n              for (int i = partialColumn.length; i < max; ++i) filler,\r\n          ],\r\n    ];\r\n\r\n    /// Build the matrix.\r\n    ///   If y is [at],\r\n    ///     we put the transpose of the normalized.\r\n    ///   else, we just use the row of data.\r\n    _List2d<E> built = <List<E>>[\r\n      for (int y = 0; y < verticalLength; ++y)\r\n        if (y == at) //\r\n          ...<List<E>>[\r\n          for (int _y = 0; _y < max; ++_y) <E>[for (int x = 0; x < horizontalLength; ++x) normalized[x][_y]]\r\n        ] else\r\n          data[y]\r\n    ];\r\n\r\n    return Matrix<E>(built);\r\n  }\r\n\r\n  Matrix<E> mapColumn(int index, E Function(E element) handler) => Matrix<E>(<List<E>>[\r\n        for (List<E> row in data)\r\n          <E>[\r\n            for (int i = 0; i < row.length; i++)\r\n              if (i == index) handler(row[i]) else row[i]\r\n          ],\r\n      ]);\r\n\r\n  Matrix<E> mapRow<R extends E>(int index, E Function(E element) handler) => Matrix<E>(<List<E>>[\r\n        for (int i = 0; i < data.length; i++)\r\n          <E>[\r\n            for (E item in data[i])\r\n              if (i == index) handler(item) else item\r\n          ],\r\n      ]);\r\n\r\n  Matrix<R> matrixMap<R>(R Function(E element) handler) => Matrix<R>(<List<R>>[\r\n        for (List<E> row in data) <R>[for (E item in row) handler(item)]\r\n      ]);\r\n\r\n  bool matrixAny(bool Function(E element) handler) => data.any((List<E> row) => row.any(handler));\r\n  bool matrixEvery(bool Function(E element) handler) => data.every((List<E> row) => row.every(handler));\r\n\r\n  Matrix<E> copy() => Matrix<E>(<List<E>>[\r\n        for (List<E> row in data) <E>[for (E item in row) item]\r\n      ]);\r\n\r\n  int get verticalLength => data.length;\r\n  int get horizontalLength => _safeLength;\r\n\r\n  int get _safeLength => data.map((List<E> row) => row.length).min();\r\n\r\n  String _buildString(Matrix<String> stringified) {\r\n    List<int> profile = stringified\r\n        .transpose() //\r\n        .data\r\n        .map((List<String> row) => row.map((String v) => v.length + 3).max())\r\n        .toList();\r\n\r\n    StringBuffer buffer = StringBuffer();\r\n    for (List<String> row in stringified.data) {\r\n      for (int i = 0; i < row.length; i++) {\r\n        buffer.write(\"${\" \" * (profile[i] - row[i].length)}${row[i]} \");\r\n      }\r\n      buffer.writeln();\r\n    }\r\n\r\n    return buffer.toString();\r\n  }\r\n\r\n  @override\r\n  String toString() {\r\n    Matrix<String> stringified = matrixMap((E element) => element.toString());\r\n\r\n    return _buildString(stringified);\r\n  }\r\n\r\n  String toRationalizedString() {\r\n    if (matrixAny((E v) => v is! NumberLike)) {\r\n      throw TypeError();\r\n    }\r\n\r\n    Matrix<String> stringified = matrixMap((E v) => (v as NumberLike<void>).strRat);\r\n\r\n    return _buildString(stringified);\r\n  }\r\n\r\n  String toNumericalString() {\r\n    if (matrixAny((E v) => v is! NumberLike)) {\r\n      throw TypeError();\r\n    }\r\n\r\n    Matrix<String> stringified = matrixMap((E v) => (v as NumberLike<void>).strShort);\r\n\r\n    return _buildString(stringified);\r\n  }\r\n\r\n  static String _renderMatrixString(String input) {\r\n    StringBuffer buffer = StringBuffer();\r\n    List<String> lines = input.split(\"\\n\");\r\n    int fullWidth = lines.map((String v) => v.length).max();\r\n\r\n    buffer\r\n      ..write(\"┌ \")\r\n      ..write(\" \" * fullWidth)\r\n      ..writeln(\" ┐\");\r\n\r\n    for (String line in lines) {\r\n      buffer\r\n        ..write(\"│ \")\r\n        ..write(line)\r\n        ..writeln(\" │\");\r\n    }\r\n\r\n    buffer\r\n      ..write(\"└ \")\r\n      ..write(\" \" * fullWidth)\r\n      ..writeln(\" ┘\");\r\n\r\n    return buffer.toString();\r\n  }\r\n\r\n  static List<int> _countColumnLengths(Matrix<String> components) {\r\n    List<int> profile = components.columnVectors //\r\n        .map((Vector<String> v) => v.data.map((String v) => v.length).max())\r\n        .toList();\r\n\r\n    return profile;\r\n  }\r\n\r\n  String toMatrixString() {\r\n    StringBuffer renderBuffer = StringBuffer();\r\n    Matrix<String> components = matrixMap((E v) => \"$v\");\r\n    List<int> profile = _countColumnLengths(components);\r\n\r\n    String rowSeparator = \"  \";\r\n    _List2d<String> data = components.data;\r\n\r\n    for (int y = 0; y < data.length; ++y) {\r\n      List<String> row = data[y];\r\n\r\n      for (int x = 0; x < horizontalLength; ++x) {\r\n        String base = row[x].padLeft(profile[x]);\r\n\r\n        renderBuffer.write(base);\r\n        if (x < row.length - 1) {\r\n          renderBuffer.write(rowSeparator);\r\n        }\r\n      }\r\n\r\n      if (y < data.length - 1) {\r\n        renderBuffer.writeln();\r\n      }\r\n    }\r\n\r\n    String contents = renderBuffer.toString();\r\n    String matrixString = _renderMatrixString(contents);\r\n\r\n    return matrixString;\r\n  }\r\n\r\n  String toCsvString() {\r\n    StringBuffer renderBuffer = StringBuffer();\r\n    Matrix<String> components = matrixMap((E v) => \"$v\");\r\n    List<int> profile = _countColumnLengths(components);\r\n\r\n    String rowSeparator = \",\";\r\n    _List2d<String> data = components.data;\r\n\r\n    for (int y = 0; y < data.length; ++y) {\r\n      List<String> row = data[y];\r\n\r\n      for (int x = 0; x < horizontalLength; ++x) {\r\n        String base = row[x].padRight(profile[x]);\r\n\r\n        renderBuffer.write(base);\r\n        if (x < row.length - 1) {\r\n          renderBuffer.write(rowSeparator);\r\n        }\r\n      }\r\n      if (y < data.length - 1) {\r\n        renderBuffer.writeln();\r\n      }\r\n    }\r\n\r\n    return renderBuffer.toString();\r\n  }\r\n\r\n  List<Vector<E>> get rowVectors => _ListVectorProxy<E>(this, <List<(int, int)>>[\r\n        for (int y = 0; y < verticalLength; ++y) //\r\n          <(int, int)>[for (int x = 0; x < horizontalLength; ++x) (y, x)]\r\n      ]);\r\n  List<Vector<E>> get columnVectors => _ListVectorProxy<E>(this, <List<(int, int)>>[\r\n        for (int x = 0; x < horizontalLength; ++x) //\r\n          <(int, int)>[for (int y = 0; y < verticalLength; ++y) (y, x)]\r\n      ]);\r\n  List<Vector<E>> get rightDiagonalVectors => _ListVectorProxy<E>(this, <List<(int, int)>>[\r\n        for (int x = 0; x < horizontalLength; ++x) //\r\n          <(int, int)>[for (int y = 0; y < verticalLength; ++y) (y, (y + x) % horizontalLength)]\r\n      ]);\r\n  List<Vector<E>> get leftDiagonalVectors => _ListVectorProxy<E>(this, <List<(int, int)>>[\r\n        for (int x = 0; x < horizontalLength; ++x) //\r\n          <(int, int)>[for (int y = 0; y < verticalLength; ++y) (y, (horizontalLength + y - x) % horizontalLength)]\r\n      ]);\r\n  Vector<E> operator [](int index) => Vector<E>(data[index]);\r\n  void operator []=(int index, Vector<E> val) => data[index] = val.data;\r\n\r\n  @override\r\n  Iterator<E> get iterator => _iterable.iterator;\r\n}\r\n"
        }
    ]
}