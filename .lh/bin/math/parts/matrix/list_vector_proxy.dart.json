{
    "sourceFile": "bin/math/parts/matrix/list_vector_proxy.dart",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1698396659471,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1698396659471,
            "name": "Commit-0",
            "content": "part of \"../../matrix.dart\";\r\n\r\nclass _ListVectorProxy<E> implements List<Vector<E>> {\r\n\r\n  _ListVectorProxy(this.parent, this.indices);\r\n  static Never _unsupported(String message) =>\r\n      throw UnsupportedError(\"$message is not supported for a vector list view.\");\r\n\r\n  final Matrix<E> parent;\r\n  final List<List<(int, int)>> indices;\r\n\r\n  List<Vector<E>> get mirror => <Vector<E>>[\r\n        for (List<(int, int)> list in indices) //\r\n          Vector<E>(<E>[for (var (int y, int x) in list) parent[y][x]]),\r\n      ];\r\n\r\n  @override\r\n  Vector<E> get first => mirror.first;\r\n\r\n  @override\r\n  set first(Vector<E> value) {\r\n    for (int i = 0; i < indices.length; ++i) {\r\n      (int, int) index = indices.first[i];\r\n\r\n      parent[index.$1][index.$2] = value[i];\r\n    }\r\n  }\r\n\r\n  @override\r\n  Vector<E> get last => mirror.last;\r\n\r\n  @override\r\n  set last(Vector<E> value) {\r\n    for (int i = 0; i < indices.length; ++i) {\r\n      (int, int) index = indices.last[i];\r\n\r\n      parent[index.$1][index.$2] = value[i];\r\n    }\r\n  }\r\n\r\n  @override\r\n  int get length => indices.length;\r\n\r\n  @override\r\n  set length(int newLength) {\r\n    indices.length = newLength;\r\n  }\r\n\r\n  @override\r\n  List<Vector<E>> operator +(List<Vector<E>> other) => _unsupported(\"operator +\");\r\n\r\n  @override\r\n  Vector<E> operator [](int index) => mirror[index];\r\n\r\n  @override\r\n  void operator []=(int index, Vector<E> value) {\r\n    if (value.data.length < indices.length) {\r\n      throw ArgumentError.value(value, \"value\", \"Replacement vector must match the original vector length!\");\r\n    }\r\n\r\n    for (int i = 0; i < indices.length; ++i) {\r\n      (int, int) pair = indices[index][i];\r\n\r\n      parent[pair.$1][pair.$2] = value[i];\r\n    }\r\n  }\r\n\r\n  @override\r\n  void add(Vector<E> value) => _unsupported(\"add\");\r\n\r\n  @override\r\n  void addAll(Iterable<Vector<E>> iterable) => _unsupported(\"addAll\");\r\n\r\n  @override\r\n  bool any(bool Function(Vector<E> element) test) => mirror.any(test);\r\n\r\n  @override\r\n  Map<int, Vector<E>> asMap() => mirror.asMap();\r\n\r\n  @override\r\n  List<R> cast<R>() => mirror.cast<R>();\r\n\r\n  @override\r\n  void clear() => _unsupported(\"clear\");\r\n\r\n  @override\r\n  bool contains(Object? element) => mirror.contains(element);\r\n\r\n  @override\r\n  Vector<E> elementAt(int index) => mirror.elementAt(index);\r\n\r\n  @override\r\n  bool every(bool Function(Vector<E> element) test) => mirror.every(test);\r\n\r\n  @override\r\n  Iterable<T> expand<T>(Iterable<T> Function(Vector<E> element) toElements) => _unsupported(\"expand\");\r\n\r\n  @override\r\n  void fillRange(int start, int end, [Vector<E>? fillValue]) => _unsupported(\"fillRange\");\r\n\r\n  @override\r\n  Vector<E> firstWhere(bool Function(Vector<E> element) test, {Vector<E> Function()? orElse}) =>\r\n      mirror.firstWhere(test, orElse: orElse);\r\n\r\n  @override\r\n  T fold<T>(T initialValue, T Function(T previousValue, Vector<E> element) combine) =>\r\n      mirror.fold(initialValue, combine);\r\n\r\n  @override\r\n  Iterable<Vector<E>> followedBy(Iterable<Vector<E>> other) => _unsupported(\"followedBy\");\r\n\r\n  @override\r\n  void forEach(void Function(Vector<E> element) action) {}\r\n\r\n  @override\r\n  Iterable<Vector<E>> getRange(int start, int end) => mirror.getRange(start, end);\r\n\r\n  @override\r\n  int indexOf(Vector<E> element, [int start = 0]) => mirror.indexOf(element, start);\r\n\r\n  @override\r\n  int indexWhere(bool Function(Vector<E> element) test, [int start = 0]) => mirror.indexWhere(test, start);\r\n\r\n  @override\r\n  void insert(int index, Vector<E> element) => _unsupported(\"insert\");\r\n\r\n  @override\r\n  void insertAll(int index, Iterable<Vector<E>> iterable) => _unsupported(\"insertAll\");\r\n\r\n  @override\r\n  bool get isEmpty => mirror.isEmpty;\r\n\r\n  @override\r\n  bool get isNotEmpty => mirror.isNotEmpty;\r\n\r\n  @override\r\n  Iterator<Vector<E>> get iterator => mirror.iterator;\r\n\r\n  @override\r\n  String join([String separator = \"\"]) => mirror.join(separator);\r\n\r\n  @override\r\n  int lastIndexOf(Vector<E> element, [int? start]) => mirror.lastIndexOf(element, start);\r\n\r\n  @override\r\n  int lastIndexWhere(bool Function(Vector<E> element) test, [int? start]) => mirror.lastIndexWhere(test, start);\r\n\r\n  @override\r\n  Vector<E> lastWhere(bool Function(Vector<E> element) test, {Vector<E> Function()? orElse}) =>\r\n      mirror.lastWhere(test, orElse: orElse);\r\n\r\n  @override\r\n  Iterable<T> map<T>(T Function(Vector<E> e) toElement) => mirror.map(toElement);\r\n\r\n  @override\r\n  Vector<E> reduce(Vector<E> Function(Vector<E> value, Vector<E> element) combine) => mirror.reduce(combine);\r\n\r\n  @override\r\n  bool remove(Object? value) => _unsupported(\"remove\");\r\n\r\n  @override\r\n  Vector<E> removeAt(int index) => _unsupported(\"removeAt\");\r\n\r\n  @override\r\n  Vector<E> removeLast() => _unsupported(\"removeLast\");\r\n\r\n  @override\r\n  void removeRange(int start, int end) => _unsupported(\"removeRange\");\r\n\r\n  @override\r\n  void removeWhere(bool Function(Vector<E> element) test) => _unsupported(\"removeWhere\");\r\n\r\n  @override\r\n  void replaceRange(int start, int end, Iterable<Vector<E>> replacements) {\r\n    List<Vector<E>> taken = replacements.toList();\r\n\r\n    for (int i = start; i < end; ++i) {\r\n      List<(int, int)> indices = this.indices[i];\r\n      Vector<E> replacement = taken[i - start];\r\n\r\n      for (int j = 0; j < indices.length; ++j) {\r\n        var (int y, int x) = indices[j];\r\n\r\n        parent[y][x] = replacement[j];\r\n      }\r\n    }\r\n  }\r\n\r\n  @override\r\n  void retainWhere(bool Function(Vector<E> element) test) => indices\r\n      .retainWhere((List<(int, int)> values) => test(Vector<E>(<E>[for (var (int y, int x) in values) parent[y][x]])));\r\n\r\n  @override\r\n  Iterable<Vector<E>> get reversed => _ListVectorProxy<E>(parent, indices.reversed.toList());\r\n\r\n  @override\r\n  void setAll(int index, Iterable<Vector<E>> iterable) => setRange(index, iterable.length, iterable);\r\n\r\n  @override\r\n  void setRange(int start, int end, Iterable<Vector<E>> iterable, [int skipCount = 0]) {\r\n    List<Vector<E>> taken = iterable.skip(skipCount).toList();\r\n\r\n    for (int i = start; i < end; ++i) {\r\n      List<(int, int)> indices = this.indices[i];\r\n      Vector<E> replacement = taken[i - start];\r\n\r\n      for (int j = 0; j < indices.length; ++j) {\r\n        var (int y, int x) = indices[j];\r\n\r\n        parent[y][x] = replacement[j];\r\n      }\r\n    }\r\n  }\r\n\r\n  @override\r\n  void shuffle([r_math.Random? random]) => _unsupported(\"shuffle\");\r\n\r\n  @override\r\n  Vector<E> get single => mirror.single;\r\n\r\n  @override\r\n  Vector<E> singleWhere(bool Function(Vector<E> element) test, {Vector<E> Function()? orElse}) =>\r\n      mirror.singleWhere(test, orElse: orElse);\r\n\r\n  @override\r\n  Iterable<Vector<E>> skip(int count) => mirror.skip(count);\r\n\r\n  @override\r\n  Iterable<Vector<E>> skipWhile(bool Function(Vector<E> value) test) => mirror.skipWhile(test);\r\n\r\n  @override\r\n  void sort([int Function(Vector<E> a, Vector<E> b)? compare]) {\r\n    indices.sort(compare == null\r\n        ? null\r\n        : (List<(int, int)> a, List<(int, int)> b) => compare.call(\r\n              Vector<E>(<E>[for (var (int y, int x) in a) parent[y][x]]),\r\n              Vector<E>(<E>[for (var (int y, int x) in b) parent[y][x]]),\r\n            ),);\r\n  }\r\n\r\n  @override\r\n  List<Vector<E>> sublist(int start, [int? end]) => mirror.sublist(start, end);\r\n\r\n  @override\r\n  Iterable<Vector<E>> take(int count) => mirror.take(count);\r\n\r\n  @override\r\n  Iterable<Vector<E>> takeWhile(bool Function(Vector<E> value) test) => mirror.takeWhile(test);\r\n\r\n  @override\r\n  List<Vector<E>> toList({bool growable = true}) => mirror;\r\n\r\n  @override\r\n  Set<Vector<E>> toSet() => mirror.toSet();\r\n\r\n  @override\r\n  String toString() => mirror.toString();\r\n\r\n  @override\r\n  Iterable<Vector<E>> where(bool Function(Vector<E> element) test) => mirror.where(test);\r\n\r\n  @override\r\n  Iterable<T> whereType<T>() => mirror.whereType();\r\n}\r\n"
        }
    ]
}