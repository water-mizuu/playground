{
    "sourceFile": "bin/math/parts/matrix/numerical_matrix.dart",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 1,
            "patches": [
                {
                    "date": 1698396659471,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1700007200520,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -222,15 +222,15 @@\n     NumericalMatrix q = qr.orthogonal;\r\n     NumericalMatrix r = qr.upper;\r\n \r\n     NumericalVector previous = NumericalVector(<Scalar>[for (int i = 0; i < verticalLength; ++i) 0.re]);\r\n-    NumericalMatrix accuQ = q;\r\n+    NumericalMatrix accumulatedQ = q;\r\n     for (int k = 0; k <= 100; ++k) {\r\n       NumericalMatrix a0 = r * q;\r\n       QRFactorization qr0 = a0.qrFactorization();\r\n       NumericalMatrix q0 = qr0.orthogonal;\r\n       NumericalMatrix r0 = qr0.upper;\r\n-      NumericalMatrix accumulative = accuQ * q0;\r\n+      NumericalMatrix accumulative = accumulatedQ * q0;\r\n \r\n       NumericalVector estimates = a0.rightDiagonalVectors.first;\r\n       Scalar deviation = 0\r\n           .to(estimates.degree) //\r\n@@ -243,12 +243,12 @@\n       a = a0;\r\n       q = q0;\r\n       r = r0;\r\n       previous = estimates;\r\n-      accuQ = accumulative;\r\n+      accumulatedQ = accumulative;\r\n     }\r\n \r\n-    NumericalMatrix vectorMatrix = accuQ.collapsed;\r\n+    NumericalMatrix vectorMatrix = accumulatedQ.collapsed;\r\n     NumericalMatrix diagonalMatrix = a.collapsed;\r\n \r\n     return EigenEstimation(vectorMatrix, diagonalMatrix);\r\n   }\r\n"
                }
            ],
            "date": 1698396659471,
            "name": "Commit-0",
            "content": "part of \"../../matrix.dart\";\r\n\r\n/// BEWARE:\r\n///   Not everything works here.\r\n\r\nextension NumericalMatrixMethods on NumericalMatrix {\r\n  static NumericalMatrix eye(int dimensions) => NumericalMatrix(<List<Scalar>>[\r\n        for (int y = 0; y < dimensions; ++y)\r\n          <Scalar>[\r\n            for (int x = 0; x < dimensions; ++x)\r\n              if (y == x) 1.c else 0.c,\r\n          ],\r\n      ]);\r\n\r\n  static NumericalMatrix ones(int height, [int? width]) => NumericalMatrix(<List<Scalar>>[\r\n        for (int y = 0; y < height; ++y) //\r\n          <Scalar>[for (int x = 0; x < (width ?? height); ++x) 1.c],\r\n      ]);\r\n\r\n  static NumericalMatrix zeros(int height, [int? width]) => NumericalMatrix(<List<Scalar>>[\r\n        for (int y = 0; y < height; ++y) //\r\n          <Scalar>[for (int x = 0; x < (width ?? height); ++x) 0.c],\r\n      ]);\r\n\r\n  static NumericalMatrix companion(List<Scalar> scalars) => zeros(1, scalars.length - 2) //\r\n      .verticalConcatenate(down: eye(scalars.length - 2))\r\n      .horizontalConcatenate(\r\n        right: NumericalMatrix.fromVectors(<NumericalVector>[\r\n          NumericalVector(<Scalar>[for (int i = 0; i < scalars.length - 1; ++i) -scalars[i]]),\r\n        ]),\r\n      );\r\n\r\n  List<int> get dimensions => <int>[verticalLength, horizontalLength];\r\n\r\n  void swapRows(int rowA, int rowB) {\r\n    List<Scalar> temp = List<Scalar>.from(data[rowA]);\r\n    data[rowA] = List<Scalar>.from(data[rowB]);\r\n    data[rowB] = temp;\r\n  }\r\n\r\n  NumericalMatrix scale(Scalar scalar) => NumericalMatrix(<List<Scalar>>[\r\n        for (int y = 0; y < verticalLength; ++y) //\r\n          <Scalar>[for (int x = 0; x < horizontalLength; ++x) scalar * data[y][x]],\r\n      ]);\r\n\r\n  NumericalMatrix get collapsed => matrixMap((Scalar v) => v.collapsed);\r\n\r\n  Scalar minorCofactorExpansion(int y, int x) {\r\n    NumericalMatrix minorMatrix = removed(y: <int>{y}, x: <int>{x});\r\n    Scalar determinant = minorMatrix.determinantCofactorExpansion();\r\n\r\n    return determinant;\r\n  }\r\n\r\n  Scalar determinantCofactorExpansion() {\r\n    if (verticalLength != horizontalLength) {\r\n      throw ArgumentError(\"A non-square matrix does not have a determinant!\");\r\n    }\r\n\r\n    if (verticalLength == 1) {\r\n      return data[0][0];\r\n    }\r\n\r\n    List<Scalar> cofactors = <Scalar>[\r\n      for (int x = 0; x < horizontalLength; ++x) //\r\n        r_math.pow(-1, x).c * data[0][x] * minorCofactorExpansion(0, x),\r\n    ];\r\n    Scalar sum = cofactors.sum();\r\n\r\n    return sum;\r\n  }\r\n\r\n  NumericalMatrix inverseCofactorExpansion() {\r\n    int vertical = verticalLength;\r\n    int horizontal = horizontalLength;\r\n\r\n    if (vertical != horizontal) {\r\n      throw ArgumentError(\"A non-square matrix does not have a determinant!\");\r\n    }\r\n\r\n    Scalar determinant = determinantCofactorExpansion();\r\n    if (determinant == 0.c) {\r\n      throw StateError(\"A singular matrix does not have a determinant!\");\r\n    }\r\n\r\n    NumericalMatrix cofactorMatrix = NumericalMatrix(<List<Scalar>>[\r\n      for (int y = 0; y < vertical; ++y)\r\n        <Scalar>[\r\n          for (int x = 0; x < horizontal; ++x) //\r\n            r_math.pow(-1, y + x).c * minorCofactorExpansion(y, x),\r\n        ],\r\n    ]);\r\n    NumericalMatrix adjugateMatrix = cofactorMatrix.transpose();\r\n\r\n    return adjugateMatrix.scale(1.c / determinant);\r\n  }\r\n\r\n  LUFactorization luFactorization() {\r\n    int vertical = verticalLength;\r\n\r\n    NumericalMatrix lower = NumericalMatrixMethods.eye(vertical);\r\n    NumericalMatrix upper = copy();\r\n\r\n    for (int p = 0; p < vertical; ++p) {\r\n      if (upper[p][p] == 0.c) {\r\n        throw StateError(\"Unexpected zero pivot at E[$p][$p] in matrix.\\nM =\\n${toNumericalString()}\");\r\n      }\r\n\r\n      for (int y = p + 1; y < vertical; ++y) {\r\n        Scalar scalar = -upper[y][p] / upper[p][p];\r\n\r\n        upper[y] += upper[p].scale(scalar);\r\n        lower[y] -= lower[p].scale(scalar);\r\n      }\r\n    }\r\n\r\n    return LUFactorization(lower, upper);\r\n  }\r\n\r\n  PLUFactorization pluFactorization([int flags = 0]) {\r\n    bool permuteOnZeroOnly = flags & PLUFactorization.permuteOnZeroOnly != 0;\r\n\r\n    int vertical = verticalLength;\r\n\r\n    NumericalMatrix permutations = NumericalMatrixMethods.eye(vertical);\r\n    NumericalMatrix lower = NumericalMatrixMethods.eye(vertical);\r\n    NumericalMatrix upper = copy();\r\n    int permutationCount = 0;\r\n\r\n    for (int p = 0; p < vertical; ++p) {\r\n      /// Pivot Resolution\r\n      /// If the pivot is zero, force permutation regardless of flag.\r\n      ///   Else, permute if the flag is false.\r\n      if (upper[p][p] == 0.c || !permuteOnZeroOnly) {\r\n        int swap = p;\r\n        for (int y = p; y < vertical; ++y) {\r\n          if (upper[y][p].abs() < upper[swap][p].abs()) {\r\n            {\r\n              continue;\r\n            }\r\n          }\r\n\r\n          swap = y;\r\n        }\r\n        if (swap != p) {\r\n          upper.swapRows(swap, p);\r\n          permutations.swapRows(swap, p);\r\n\r\n          for (int x = 0; x < p; ++x) {\r\n            Scalar temp = lower[swap][x];\r\n            lower[swap][x] = lower[p][x];\r\n            lower[p][x] = temp;\r\n          }\r\n          ++permutationCount;\r\n        }\r\n        if (upper[swap][p] == 0.c) {\r\n          {\r\n            continue;\r\n          }\r\n        }\r\n      }\r\n\r\n      for (int y = p + 1; y < vertical; ++y) {\r\n        Scalar scalar = -upper[y][p] / upper[p][p];\r\n\r\n        upper[y] += upper[p].scale(scalar);\r\n        lower[y] -= lower[p].scale(scalar);\r\n      }\r\n    }\r\n\r\n    return PLUFactorization(permutations, lower, upper, permutationCount);\r\n  }\r\n\r\n  Scalar determinantLuFactorization() {\r\n    PLUFactorization factorization = pluFactorization();\r\n    NumericalMatrix upper = factorization.upper;\r\n    Scalar diagonal = <Scalar>[for (int y = 0; y < verticalLength; ++y) upper[y][y]].product();\r\n    Scalar determinant = r_math.pow(-1, factorization.permutationCount).c * diagonal;\r\n\r\n    return determinant;\r\n  }\r\n\r\n  QRFactorization qrFactorization() {\r\n    NumericalMatrix makeHouseholder(NumericalVector vector) {\r\n      Scalar scalar = vector[0] + vector.magnitude * vector[0].sign;\r\n      NumericalVector v = vector.scale(1.c / scalar);\r\n      v[0] = 1.c;\r\n\r\n      Scalar beta = 2.c / v.dot(v).abs();\r\n      NumericalMatrix matrix = NumericalMatrix.fromVectors(<NumericalVector>[v]);\r\n      NumericalMatrix matrixT = matrix.transpose();\r\n      NumericalMatrix hMatrix = NumericalMatrixMethods.eye(vector.degree) - (matrix * matrixT).scale(beta);\r\n\r\n      return hMatrix;\r\n    }\r\n\r\n    int horizontal = horizontalLength;\r\n    int vertical = verticalLength;\r\n\r\n    NumericalMatrix A = copy();\r\n    NumericalMatrix Q = eye(vertical);\r\n    for (int i = 0; i < horizontal - (horizontal == vertical ? 1 : 0); ++i) {\r\n      NumericalMatrix H = eye(vertical);\r\n      NumericalMatrix submatrix = makeHouseholder(A.columnVectors[i].subvector(top: i));\r\n\r\n      for (int y = i; y < vertical; ++y) {\r\n        for (int x = i; x < horizontal; ++x) {\r\n          H[y][x] = submatrix[y - i][x - i];\r\n        }\r\n      }\r\n\r\n      Q = Q * H;\r\n      A = H * A;\r\n    }\r\n\r\n    return QRFactorization(Q, A);\r\n  }\r\n\r\n  EigenEstimation eigenvalueEstimation() {\r\n    QRFactorization qr = qrFactorization();\r\n    NumericalMatrix a = copy();\r\n    NumericalMatrix q = qr.orthogonal;\r\n    NumericalMatrix r = qr.upper;\r\n\r\n    NumericalVector previous = NumericalVector(<Scalar>[for (int i = 0; i < verticalLength; ++i) 0.re]);\r\n    NumericalMatrix accuQ = q;\r\n    for (int k = 0; k <= 100; ++k) {\r\n      NumericalMatrix a0 = r * q;\r\n      QRFactorization qr0 = a0.qrFactorization();\r\n      NumericalMatrix q0 = qr0.orthogonal;\r\n      NumericalMatrix r0 = qr0.upper;\r\n      NumericalMatrix accumulative = accuQ * q0;\r\n\r\n      NumericalVector estimates = a0.rightDiagonalVectors.first;\r\n      Scalar deviation = 0\r\n          .to(estimates.degree) //\r\n          .map((int i) => (previous[i] - estimates[i]).abs())\r\n          .variance();\r\n\r\n      if (0.re <= deviation && deviation <= 1e-16.re) {\r\n        break;\r\n      }\r\n      a = a0;\r\n      q = q0;\r\n      r = r0;\r\n      previous = estimates;\r\n      accuQ = accumulative;\r\n    }\r\n\r\n    NumericalMatrix vectorMatrix = accuQ.collapsed;\r\n    NumericalMatrix diagonalMatrix = a.collapsed;\r\n\r\n    return EigenEstimation(vectorMatrix, diagonalMatrix);\r\n  }\r\n\r\n  EigenObjects eigenObjects() {\r\n    if (verticalLength != horizontalLength) {\r\n      throw UnsupportedError(\"[eigenObjects] is not supported for non-square matrices!\");\r\n    }\r\n\r\n    int size = verticalLength;\r\n    EigenEstimation estimation = eigenvalueEstimation();\r\n    List<Scalar> values = estimation.eigenvalues.map((Scalar v) => v.collapse()).toSet().toList();\r\n    List<NumericalVector> vectors = <NumericalVector>[\r\n      // A - λI\r\n      for (Matrix<Complex> eigenMatrix in values.map(NumericalMatrixMethods.eye(size).scale)) //\r\n        ...(this - eigenMatrix).nullBasis(),\r\n    ];\r\n\r\n    NumericalMatrix diagonal = NumericalMatrixMethods.eye(size)..leftDiagonalVectors[0] = NumericalVector(values);\r\n    NumericalMatrix eigenMatrix = NumericalMatrix.fromVectors(vectors);\r\n\r\n    return EigenObjects(diagonal, eigenMatrix);\r\n  }\r\n\r\n  RowReduction reducedRowEchelonForm([int flags = 0]) {\r\n    bool permuteOnZeroOnly = flags & RowReduction.permuteOnZeroOnly != 0;\r\n    bool preserveRowOrder = flags & RowReduction.preserveRowOrder != 0;\r\n\r\n    int vertical = verticalLength;\r\n    int horizontal = horizontalLength;\r\n    int diagonal = r_math.min(vertical, horizontal);\r\n\r\n    Set<int> ignoreColumns = <int>{};\r\n    NumericalMatrix copy = this.copy();\r\n    NumericalMatrix permutations = NumericalMatrixMethods.eye(vertical);\r\n\r\n    for (int p = 0; p < diagonal; ++p) {\r\n      int swap = p;\r\n      if (copy[p][p] == 0.c || !permuteOnZeroOnly) {\r\n        for (int y = p + 1; y < vertical; ++y) {\r\n          if (copy[y][p].abs() < copy[swap][p].abs()) {\r\n            continue;\r\n          }\r\n\r\n          swap = y;\r\n        }\r\n      }\r\n\r\n      if (swap != p) {\r\n        copy.swapRows(swap, p);\r\n        permutations.swapRows(swap, p);\r\n      }\r\n      if (copy[p][p] == 0.c) {\r\n        continue;\r\n      }\r\n\r\n      Scalar divisor = copy[p][p];\r\n      copy[p] = copy[p].scale(divisor.multiplicativeInverse);\r\n\r\n      for (int y = p + 1; y < vertical; ++y) {\r\n        Scalar scalar = -copy[y][p] / copy[p][p];\r\n\r\n        copy[y] += copy[p].scale(scalar);\r\n      }\r\n    }\r\n\r\n    for (int p = diagonal - 1; p >= 0; --p) {\r\n      if (ignoreColumns.contains(p) || copy[p][p] == 0.c) {\r\n        continue;\r\n      }\r\n      for (int y = p - 1; y >= 0; --y) {\r\n        Scalar scalar = -copy[y][p] / copy[p][p];\r\n\r\n        copy[y] += copy[p].scale(scalar);\r\n      }\r\n    }\r\n\r\n    NumericalMatrix reduced = !preserveRowOrder //\r\n        ? copy\r\n        : permutations.transpose() * copy;\r\n\r\n    return RowReduction(reduced);\r\n  }\r\n\r\n  NumericalMatrix inverseGaussianElimination() {\r\n    NumericalMatrix identity = NumericalMatrixMethods.eye(verticalLength);\r\n    NumericalMatrix augmented = horizontalConcatenate(right: identity);\r\n    RowReduction reduction = augmented.reducedRowEchelonForm();\r\n    NumericalMatrix reduced = reduction.reduced;\r\n    NumericalMatrix inverse = reduced.submatrix(left: verticalLength);\r\n\r\n    return inverse;\r\n  }\r\n\r\n  List<MapEntry<int, NumericalVector>> nullVectors([RowReduction? reduction]) {\r\n    reduction ??= reducedRowEchelonForm();\r\n\r\n    // We need to eliminate linearly dependent rows AND columns.\r\n    NumericalMatrix hyperReduced = reduction.reduced //\r\n        .transpose()\r\n        .matrixMap((Scalar v) => v.collapsed)\r\n        .reducedRowEchelonForm()\r\n        .reduced;\r\n\r\n    List<NumericalVector> vectors = hyperReduced.rowVectors;\r\n    List<MapEntry<int, NumericalVector>> nullVectors = 0\r\n        .to(vectors.length) //\r\n        .where((int i) {\r\n          NumericalVector vector = vectors[i];\r\n          for (int i = vector.degree - 1; i >= 0; --i) {\r\n            if (vector[i] == 0.c) {\r\n              continue;\r\n            }\r\n            if (vector[i] == 1.c) {\r\n              return false;\r\n            }\r\n            return true;\r\n          }\r\n          return true;\r\n        })\r\n        .map((int i) => MapEntry<int, Vector<Complex>>(i, vectors[i]))\r\n        .toList();\r\n\r\n    return nullVectors;\r\n  }\r\n\r\n  Set<NumericalVector> rowBasis() {\r\n    RowReduction reduction = reducedRowEchelonForm();\r\n    NumericalMatrix reduced = reduction.reduced.collapsed;\r\n    List<NumericalVector> vectors = reduced.rowVectors;\r\n    Set<NumericalVector> basis = <NumericalVector>{\r\n      for (int i = 0; i < verticalLength; ++i)\r\n        if (!reduced[i].data.every((Scalar v) => v == 0.c)) vectors[i],\r\n    };\r\n\r\n    return basis;\r\n  }\r\n\r\n  Set<NumericalVector> columnBasis() {\r\n    Set<int> nullIndices = nullVectors().map((MapEntry<int, NumericalVector> v) => v.key).toSet();\r\n    List<NumericalVector> vectors = columnVectors;\r\n    Set<NumericalVector> nonNullVectors = <NumericalVector>{\r\n      for (int i = 0; i < vectors.length; ++i)\r\n        if (!nullIndices.contains(i)) vectors[i],\r\n    };\r\n\r\n    return nonNullVectors;\r\n  }\r\n\r\n  Set<NumericalVector> nullBasis() {\r\n    int vertical = verticalLength;\r\n    int horizontal = horizontalLength;\r\n\r\n    RowReduction reduction = reducedRowEchelonForm();\r\n    NumericalMatrix reduced = reduction.reduced.collapsed;\r\n\r\n    List<int> freeIndices = nullVectors(reduction) //\r\n        .map((MapEntry<int, NumericalVector> entry) => entry.key)\r\n        .toList();\r\n\r\n    // Count the maximum free variables.\r\n    // This is here because sometimes, there are given where:\r\n    //    It is *not* an augmented matrix.\r\n    // Also times that it is, so ¯\\_(ツ)_/ ¯ I think it works for now.\r\n\r\n    int max = freeIndices.map((int v) => v + 1).max();\r\n    NumericalMatrix padded = max > vertical //\r\n        ? reduced.verticalConcatenate(down: zeros(max - vertical, horizontal))\r\n        : reduced;\r\n\r\n    List<NumericalVector> columnVectors = padded.columnVectors;\r\n    Set<NumericalVector> vectors = freeIndices.map((int i) {\r\n      NumericalVector vector = columnVectors[i];\r\n      NumericalVector negative = vector.scale(-1.c);\r\n      negative[i] = 1.c;\r\n\r\n      return negative;\r\n    }).toSet();\r\n\r\n    return vectors;\r\n  }\r\n\r\n  NumericalMatrix add(NumericalMatrix other) {\r\n    if (horizontalLength != other.horizontalLength || verticalLength != other.verticalLength) {\r\n      throw ArgumentError(\"Cannot add two incompatible matrices. L:$dimensions; R:${other.dimensions}\");\r\n    }\r\n\r\n    return NumericalMatrix(<List<Scalar>>[\r\n      for (int y = 0; y < verticalLength; ++y)\r\n        <Scalar>[for (int x = 0; x < horizontalLength; ++x) data[y][x] + other.data[y][x]],\r\n    ]);\r\n  }\r\n\r\n  NumericalMatrix dot(NumericalMatrix other) {\r\n    if (horizontalLength != other.verticalLength) {\r\n      throw ArgumentError(\"Cannot multiply two incompatible matrices. L:$dimensions; R:${other.dimensions}\");\r\n    }\r\n\r\n    List<NumericalVector> rowVectors = this.rowVectors;\r\n    List<NumericalVector> columnVectors = other.columnVectors;\r\n    List<NumericalVector> vectors = <NumericalVector>[\r\n      for (NumericalVector column in columnVectors) //\r\n        NumericalVector(<Scalar>[for (NumericalVector row in rowVectors) row * column]),\r\n    ];\r\n\r\n    return NumericalMatrix.fromVectors(vectors);\r\n  }\r\n\r\n  NumericalMatrix operator +(NumericalMatrix other) => add(other);\r\n  NumericalMatrix operator -(NumericalMatrix other) => add(other.additiveInverse);\r\n  NumericalMatrix operator -() => additiveInverse;\r\n\r\n  NumericalMatrix operator *(NumericalMatrix other) => dot(other);\r\n\r\n  NumericalMatrix get additiveInverse => scale(-1.c);\r\n\r\n  Scalar get determinant => determinantLuFactorization();\r\n\r\n  ElementWiseNumericalMatrixProxy get elementWise => ElementWiseNumericalMatrixProxy(this);\r\n}\r\n\r\nclass EigenEstimation {\r\n\r\n  const EigenEstimation(this.eigenvectors, this.diagonal);\r\n  final NumericalMatrix eigenvectors;\r\n  final NumericalMatrix diagonal;\r\n\r\n  Set<Scalar> get eigenvalues {\r\n    NumericalMatrix matrix = diagonal.collapsed;\r\n    Set<Scalar> eigenvalues = <Scalar>{};\r\n\r\n    for (int p = 0; p < matrix.verticalLength; ++p) {\r\n      // Determine if it's a 1x1 or 2x2 block.\r\n\r\n      bool isComplex = p < matrix.verticalLength - 1 && matrix[p + 1][p].abs() > 1e-9.re;\r\n      if (isComplex) {\r\n        Scalar mean = 0.5.c * (matrix[p + 1][p + 1] + matrix[p][p]);\r\n        Scalar product = matrix[p][p] * matrix[p + 1][p + 1] - matrix[p][p + 1] * matrix[p + 1][p];\r\n\r\n        // m ± √(m² - p) *ping*\r\n        Scalar root1 = mean + c_math.pow(mean * mean - product, 0.5.re);\r\n        Scalar root2 = mean - c_math.pow(mean * mean - product, 0.5.re);\r\n\r\n        eigenvalues\r\n          ..add(root1)\r\n          ..add(root2);\r\n\r\n        ++p;\r\n      } else {\r\n        eigenvalues.add(matrix[p][p]);\r\n      }\r\n    }\r\n\r\n    return eigenvalues;\r\n  }\r\n}\r\n\r\nclass RowReduction {\r\n\r\n  const RowReduction(this.reduced);\r\n  static const int permuteOnZeroOnly = 1 << 0;\r\n  static const int preserveRowOrder = 1 << 1;\r\n\r\n  final NumericalMatrix reduced;\r\n}\r\n\r\nclass QRAlgorithm {\r\n\r\n  const QRAlgorithm(this.diagonal, this.eigenvectors);\r\n  final NumericalMatrix diagonal;\r\n  final NumericalMatrix eigenvectors;\r\n}\r\n\r\nclass EigenObjects {\r\n\r\n  const EigenObjects(this.diagonal, this.eigenvectors);\r\n  final NumericalMatrix diagonal;\r\n  final NumericalMatrix eigenvectors;\r\n}\r\n\r\nclass LUFactorization {\r\n\r\n  const LUFactorization(this.lower, this.upper);\r\n  final NumericalMatrix lower;\r\n  final NumericalMatrix upper;\r\n}\r\n\r\nclass PLUFactorization extends LUFactorization {\r\n\r\n  const PLUFactorization(this.permutation, super.lower, super.upper, this.permutationCount);\r\n  static const int permuteOnZeroOnly = 1 << 0;\r\n\r\n  final NumericalMatrix permutation;\r\n  final int permutationCount;\r\n}\r\n\r\nclass QRFactorization {\r\n\r\n  const QRFactorization(this.orthogonal, this.upper);\r\n  final NumericalMatrix orthogonal;\r\n  final NumericalMatrix upper;\r\n}\r\n\r\nextension MatrixPostfixExtension<E> on List<List<E>> {\r\n  Matrix<E> get mt => Matrix<E>(this);\r\n  Matrix<E> toMatrix() => Matrix<E>(this);\r\n}\r\n\r\nextension NumericalMatrixPostfixExtension<E extends num> on List<List<E>> {\r\n  Matrix<Scalar> get mt => Matrix<Scalar>(map((List<E> e) => e.map(Scalar.from).toList()).toList());\r\n  Matrix<Scalar> toMatrix() => Matrix<Scalar>(map((List<E> e) => e.map(Scalar.from).toList()).toList());\r\n}\r\n\r\nextension on Iterable<Complex> {\r\n  Complex variance() {\r\n    Complex mean = this.mean();\r\n    Complex distances = map((Complex v) => (v - mean).abs()).sum();\r\n    Complex variance = distances / length.c;\r\n\r\n    return variance;\r\n  }\r\n}\r\n"
        }
    ]
}