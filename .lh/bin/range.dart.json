{
    "sourceFile": "bin/range.dart",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 27,
            "patches": [
                {
                    "date": 1688831182705,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1688896963376,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -82,9 +82,9 @@\n   @override\r\n   bool intersects(Range other) => ranges.any((RangeBase r) => r.intersects(other));\r\n \r\n   @override\r\n-  Range union(Range other) => ranges.fold(other, (Range r, RangeBase unit) => unit.union(r));\r\n+  Range union(Range other) => \r\n \r\n   @override\r\n   bool contains(Object? value) =>\r\n       value is num && ranges.isNotEmpty && ranges.any((RangeBase u) => u.contains(value));\r\n"
                },
                {
                    "date": 1688896995116,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -82,9 +82,12 @@\n   @override\r\n   bool intersects(Range other) => ranges.any((RangeBase r) => r.intersects(other));\r\n \r\n   @override\r\n-  Range union(Range other) => \r\n+  Range union(Range other) {\r\n+    for (RangeSingle single in this.ranges.) {}\r\n+    return ranges.fold(other, (Range r, RangeBase unit) => unit.union(r));\r\n+  }\r\n \r\n   @override\r\n   bool contains(Object? value) =>\r\n       value is num && ranges.isNotEmpty && ranges.any((RangeBase u) => u.contains(value));\r\n"
                },
                {
                    "date": 1688897039053,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -83,9 +83,12 @@\n   bool intersects(Range other) => ranges.any((RangeBase r) => r.intersects(other));\r\n \r\n   @override\r\n   Range union(Range other) {\r\n-    for (RangeSingle single in this.ranges.) {}\r\n+    for (RangeSingle single in this.ranges.whereType<RangeSingle>()) {\r\n+      i\r\n+    }\r\n+\r\n     return ranges.fold(other, (Range r, RangeBase unit) => unit.union(r));\r\n   }\r\n \r\n   @override\r\n"
                },
                {
                    "date": 1688897039081,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -84,9 +84,9 @@\n \r\n   @override\r\n   Range union(Range other) {\r\n     for (RangeSingle single in this.ranges.whereType<RangeSingle>()) {\r\n-      i\r\n+      if\r\n     }\r\n \r\n     return ranges.fold(other, (Range r, RangeBase unit) => unit.union(r));\r\n   }\r\n"
                },
                {
                    "date": 1688897069141,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -83,10 +83,13 @@\n   bool intersects(Range other) => ranges.any((RangeBase r) => r.intersects(other));\r\n \r\n   @override\r\n   Range union(Range other) {\r\n+    /// If we have (a, b) | b \r\n     for (RangeSingle single in this.ranges.whereType<RangeSingle>()) {\r\n-      if\r\n+      if (single case RangeSingle(:num value)) {\r\n+        ///\r\n+      }\r\n     }\r\n \r\n     return ranges.fold(other, (Range r, RangeBase unit) => unit.union(r));\r\n   }\r\n"
                },
                {
                    "date": 1688897113530,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -83,9 +83,10 @@\n   bool intersects(Range other) => ranges.any((RangeBase r) => r.intersects(other));\r\n \r\n   @override\r\n   Range union(Range other) {\r\n-    /// If we have (a, b) | b \r\n+    /// If we have ((a, b) | b) | (b, d), then we can simplify it to (a, d);\r\n+    /// \r\n     for (RangeSingle single in this.ranges.whereType<RangeSingle>()) {\r\n       if (single case RangeSingle(:num value)) {\r\n         ///\r\n       }\r\n"
                },
                {
                    "date": 1688897144071,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -84,9 +84,11 @@\n \r\n   @override\r\n   Range union(Range other) {\r\n     /// If we have ((a, b) | b) | (b, d), then we can simplify it to (a, d);\r\n-    /// \r\n+    /// Cases:\r\n+    ///   [(a, b) | b] | (b, d) => (a, d)\r\n+    ///   [(a, b) | b] | [c | (b, d)]\r\n     for (RangeSingle single in this.ranges.whereType<RangeSingle>()) {\r\n       if (single case RangeSingle(:num value)) {\r\n         ///\r\n       }\r\n"
                },
                {
                    "date": 1688897174114,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -86,12 +86,13 @@\n   Range union(Range other) {\r\n     /// If we have ((a, b) | b) | (b, d), then we can simplify it to (a, d);\r\n     /// Cases:\r\n     ///   [(a, b) | b] | (b, d) => (a, d)\r\n-    ///   [(a, b) | b] | [c | (b, d)]\r\n+    ///   [(a, b) | b] | [c | (b, d)] => (a, d)\r\n+    ///   [(a, b) | b] | [c | (b, d) | e] => (a, e)\r\n     for (RangeSingle single in this.ranges.whereType<RangeSingle>()) {\r\n       if (single case RangeSingle(:num value)) {\r\n-        ///\r\n+        if (ranges.whereType<RangeUn)\r\n       }\r\n     }\r\n \r\n     return ranges.fold(other, (Range r, RangeBase unit) => unit.union(r));\r\n"
                },
                {
                    "date": 1688897306402,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -90,9 +90,11 @@\n     ///   [(a, b) | b] | [c | (b, d)] => (a, d)\r\n     ///   [(a, b) | b] | [c | (b, d) | e] => (a, e)\r\n     for (RangeSingle single in this.ranges.whereType<RangeSingle>()) {\r\n       if (single case RangeSingle(:num value)) {\r\n-        if (ranges.whereType<RangeUn)\r\n+        if (ranges\r\n+            .whereType<RangeUnit>()\r\n+            .f((RangeUnit unit) => unit.start == value || unit.end == value)) {}\r\n       }\r\n     }\r\n \r\n     return ranges.fold(other, (Range r, RangeBase unit) => unit.union(r));\r\n"
                },
                {
                    "date": 1688897539699,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -90,11 +90,16 @@\n     ///   [(a, b) | b] | [c | (b, d)] => (a, d)\r\n     ///   [(a, b) | b] | [c | (b, d) | e] => (a, e)\r\n     for (RangeSingle single in this.ranges.whereType<RangeSingle>()) {\r\n       if (single case RangeSingle(:num value)) {\r\n-        if (ranges\r\n+        RangeUnit? socket = ranges\r\n             .whereType<RangeUnit>()\r\n-            .f((RangeUnit unit) => unit.start == value || unit.end == value)) {}\r\n+            .where((RangeUnit unit) => unit.start == value || unit.end == value)\r\n+            .firstOrNull;\r\n+\r\n+        if (socket != null) {\r\n+\r\n+        }\r\n       }\r\n     }\r\n \r\n     return ranges.fold(other, (Range r, RangeBase unit) => unit.union(r));\r\n"
                },
                {
                    "date": 1688897569937,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -96,9 +96,12 @@\n             .where((RangeUnit unit) => unit.start == value || unit.end == value)\r\n             .firstOrNull;\r\n \r\n         if (socket != null) {\r\n-\r\n+          switch (other) {\r\n+            case RangeUnit(:num start, :num end) when start == value:\r\n+              break; /// We can match!\r\n+          }\r\n         }\r\n       }\r\n     }\r\n \r\n"
                },
                {
                    "date": 1688897602359,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -97,10 +97,19 @@\n             .firstOrNull;\r\n \r\n         if (socket != null) {\r\n           switch (other) {\r\n-            case RangeUnit(:num start, :num end) when start == value:\r\n-              break; /// We can match!\r\n+            case RangeUnit(:num start, :num end) when socket.end == value && start == value:\r\n+\r\n+              /// We can match!\r\n+              break;\r\n+\r\n+            case RangeUnit(:num start, :num end) when socket.start == value && end == value:\r\n+              break;\r\n+\r\n+\r\n+            case _:\r\n+              break;\r\n           }\r\n         }\r\n       }\r\n     }\r\n"
                },
                {
                    "date": 1688897648751,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -106,8 +106,9 @@\n             case RangeUnit(:num start, :num end) when socket.start == value && end == value:\r\n               break;\r\n \r\n \r\n+\r\n             case _:\r\n               break;\r\n           }\r\n         }\r\n@@ -302,9 +303,9 @@\n         RangeUnion() => RangeUnion(<RangeBase>{this, ...other.ranges}),\r\n         RangeBase() => RangeUnion(<RangeBase>{this, other}),\r\n         RangeEmpty() => this,\r\n       };\r\n-    }\r\n+    } \r\n \r\n     /// At this point, it's guaranteed to intersect somewhere.\r\n     return switch (other) {\r\n       RangeUnion() => other.ranges.fold(this, (Range l, RangeBase r) => l.union(r)),\r\n"
                },
                {
                    "date": 1688897679009,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -105,10 +105,8 @@\n \r\n             case RangeUnit(:num start, :num end) when socket.start == value && end == value:\r\n               break;\r\n \r\n-\r\n-\r\n             case _:\r\n               break;\r\n           }\r\n         }\r\n@@ -303,16 +301,16 @@\n         RangeUnion() => RangeUnion(<RangeBase>{this, ...other.ranges}),\r\n         RangeBase() => RangeUnion(<RangeBase>{this, other}),\r\n         RangeEmpty() => this,\r\n       };\r\n-    } \r\n-\r\n-    /// At this point, it's guaranteed to intersect somewhere.\r\n-    return switch (other) {\r\n-      RangeUnion() => other.ranges.fold(this, (Range l, RangeBase r) => l.union(r)),\r\n-      RangeUnit() => this.combination(other),\r\n-      RangeSingle() || RangeEmpty() => this,\r\n-    };\r\n+    } else {\r\n+      /// At this point, it's guaranteed to intersect somewhere.\r\n+      return switch (other) {\r\n+        RangeUnion() => other.ranges.fold(this, (RangeUni l, RangeBase r) => l.union(r)),\r\n+        RangeUnit() => this.combination(other),\r\n+        RangeSingle() || RangeEmpty() => this,\r\n+      };\r\n+    }\r\n   }\r\n \r\n   @override\r\n   num get length => end - start;\r\n"
                },
                {
                    "date": 1688899659582,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,330 @@\n+import \"dart:math\" as math;\r\n+\r\n+sealed class Range {\r\n+  const factory Range.single(num value) = RangeSingle;\r\n+  factory Range.unit(num start, num end) {\r\n+    if (end <= start) {\r\n+      return const Range.empty();\r\n+    }\r\n+    return RangeUnit(start, end);\r\n+  }\r\n+\r\n+  factory Range.union(Set<RangeUnit> units) {\r\n+    units = <RangeUnit>{\r\n+      for (RangeUnit unit in units)\r\n+        if (unit.isNotEmpty) unit,\r\n+    };\r\n+    if (units.isEmpty) {\r\n+      return const Range.empty();\r\n+    }\r\n+    return RangeUnion(units);\r\n+  }\r\n+\r\n+  const factory Range.empty() = RangeEmpty;\r\n+\r\n+  bool contains(num value);\r\n+\r\n+  /// Returns `true` if the [Range] `this` covers or is a superset of another [Range]\r\n+  bool covers(Range other);\r\n+\r\n+  /// Returns `true` if the [Range] intersects with another [Range].\r\n+  bool intersects(Range other);\r\n+\r\n+  /// Returns the difference of two ranges. If the rhs (right hand side) does not\r\n+  ///   intersect with the lhs (left hand side), then the lhs is returned unmodified.\r\n+  Range difference(Range other);\r\n+\r\n+  /// Returns the intersection (common element) of a range.\r\n+  Range intersection(Range other);\r\n+\r\n+  /// Returns the union of a range. It is not guaranteed to return a [RangeUnion].\r\n+  Range union(Range other);\r\n+\r\n+  /// Returns the length of the range.\r\n+  num get length;\r\n+}\r\n+\r\n+/// A union of range units or range singles.\r\n+final class RangeUnion implements Range {\r\n+  const RangeUnion(this.ranges);\r\n+\r\n+  final Set<RangeBase> ranges;\r\n+\r\n+  @override\r\n+  bool covers(Range other) => ranges.any((RangeBase r) => r.covers(other));\r\n+\r\n+  @override\r\n+  Range difference(Range other) {\r\n+    if (!this.intersects(other)) {\r\n+      return this;\r\n+    }\r\n+\r\n+    Set<RangeBase> units = <RangeBase>{};\r\n+    for (RangeBase unit in this.ranges) {\r\n+      switch (unit.difference(other)) {\r\n+        case RangeUnit difference when difference != const Range.empty():\r\n+          units.add(difference);\r\n+        case RangeUnion difference:\r\n+          units.addAll(difference.ranges);\r\n+        case RangeEmpty _:\r\n+        default:\r\n+          break;\r\n+      }\r\n+    }\r\n+\r\n+    return RangeUnion(units);\r\n+  }\r\n+\r\n+  @override\r\n+  Range intersection(Range other) =>\r\n+      ranges.fold(other, (Range r, RangeBase unit) => unit.intersection(r));\r\n+\r\n+  @override\r\n+  bool intersects(Range other) => ranges.any((RangeBase r) => r.intersects(other));\r\n+\r\n+  @override\r\n+  Range union(Range other) {\r\n+    /// If we have ((a, b) | b) | (b, d), then we can simplify it to (a, d);\r\n+    /// Cases:\r\n+    ///   [(a, b) | b] | (b, d) => (a, d)\r\n+    ///   [(a, b) | b] | [c | (b, d)] => (a, d)\r\n+    ///   [(a, b) | b] | [c | (b, d) | e] => (a, e)\r\n+    for (RangeSingle single in this.ranges.whereType<RangeSingle>()) {\r\n+      if (single case RangeSingle(:num value)) {\r\n+        RangeUnit? socket = ranges\r\n+            .whereType<RangeUnit>()\r\n+            .where((RangeUnit unit) => unit.start == value || unit.end == value)\r\n+            .firstOrNull;\r\n+\r\n+        if (socket != null) {\r\n+          switch (other) {\r\n+            case RangeUnit(:num start, :num end) when socket.end == value && start == value:\r\n+\r\n+              /// We can match!\r\n+              /// We can match!\r\n+              break;\r\n+\r\n+            case RangeUnit(:num start, :num end) when socket.start == value && end == value:\r\n+              break;\r\n+\r\n+            case _:\r\n+              break;\r\n+          }\r\n+        }\r\n+      }\r\n+    }\r\n+\r\n+    return ranges.fold(other, (Range r, RangeBase unit) => unit.union(r));\r\n+  }\r\n+\r\n+  @override\r\n+  bool contains(Object? value) =>\r\n+      value is num && ranges.isNotEmpty && ranges.any((RangeBase u) => u.contains(value));\r\n+\r\n+  @override\r\n+  num get length => ranges.map((RangeBase u) => u.length).fold(0, (num a, num b) => a + b);\r\n+\r\n+  @override\r\n+  String toString() => isEmpty ? \"∅\" : ranges.join(\" | \");\r\n+}\r\n+\r\n+class RangeEmpty implements Range {\r\n+  const RangeEmpty();\r\n+\r\n+  @override\r\n+  bool contains(num value) => false;\r\n+\r\n+  @override\r\n+  bool covers(Range other) => other is RangeEmpty;\r\n+\r\n+  @override\r\n+  Range difference(Range other) => this;\r\n+\r\n+  @override\r\n+  Range intersection(Range other) => this;\r\n+\r\n+  @override\r\n+  bool intersects(Range other) => false;\r\n+\r\n+  @override\r\n+  Range union(Range other) => other;\r\n+\r\n+  @override\r\n+  int get length => 0;\r\n+\r\n+  @override\r\n+  String toString() => \"∅\";\r\n+}\r\n+\r\n+sealed class RangeBase implements Range {}\r\n+\r\n+final class RangeSingle implements RangeBase {\r\n+  const RangeSingle(this.value);\r\n+\r\n+  final num value;\r\n+\r\n+  @override\r\n+  bool contains(num value) => this.value == value;\r\n+\r\n+  @override\r\n+  bool covers(Range other) => other is RangeSingle && other.value == value;\r\n+\r\n+  @override\r\n+  Range difference(Range other) => switch (this.intersects(other)) {\r\n+        true => const Range.empty(),\r\n+        false => this,\r\n+      };\r\n+\r\n+  @override\r\n+  bool intersects(Range other) => switch (other) {\r\n+        RangeUnion(:Set<RangeBase> ranges) => ranges.any(this.intersects),\r\n+        RangeEmpty() => false,\r\n+        RangeSingle(:num value) => this.value == value,\r\n+        RangeUnit(:num start, :num end) => start < value && value < end,\r\n+      };\r\n+\r\n+  @override\r\n+  Range intersection(Range other) => switch (this.intersects(other)) {\r\n+        true => this,\r\n+        false => const Range.empty(),\r\n+      };\r\n+\r\n+  @override\r\n+  Range union(Range other) {\r\n+    if (other.isEmpty) {\r\n+      return this;\r\n+    }\r\n+\r\n+    if (!this.intersects(other)) {\r\n+      /// Since this doesn't intersect, then\r\n+\r\n+      return switch (other) {\r\n+        RangeUnion() => RangeUnion(<RangeBase>{this, ...other.ranges}),\r\n+        RangeBase() => RangeUnion(<RangeBase>{this, other}),\r\n+        RangeEmpty() => this,\r\n+      };\r\n+    }\r\n+\r\n+    /// At this point, it's guaranteed to intersect somewhere.\r\n+    return switch (other) {\r\n+      RangeUnion() => other.ranges.fold(this, (Range l, RangeBase r) => l.union(r)),\r\n+      RangeUnit() => other,\r\n+      RangeSingle() || RangeEmpty() => this,\r\n+    };\r\n+  }\r\n+\r\n+  @override\r\n+  num get length => 1;\r\n+\r\n+  @override\r\n+  String toString() => \"{$value}\";\r\n+}\r\n+\r\n+/// A closed interval between two, (min, max). Both are exclusive.\r\n+final class RangeUnit implements RangeBase {\r\n+  const RangeUnit(this.start, this.end);\r\n+\r\n+  final num start;\r\n+  final num end;\r\n+\r\n+  /// Returns the contingent combination of two [RangeUnit]s,\r\n+  ///   returning an equivalent [RangeUnit]\r\n+  Range combination(RangeUnit other) {\r\n+    num start = math.min(this.start, other.start);\r\n+    num end = math.max(this.end, other.end);\r\n+    if (start >= end) {\r\n+      return const Range.empty();\r\n+    }\r\n+\r\n+    return Range.unit(start, end);\r\n+  }\r\n+\r\n+  @override\r\n+  bool contains(num value) => start < value && value < end;\r\n+\r\n+  @override\r\n+  bool covers(Range other) => other is RangeSingle && contains(other.value);\r\n+\r\n+  @override\r\n+  bool intersects(Range other) => switch (other) {\r\n+        RangeUnion(:Set<RangeBase> ranges) => ranges.any(intersects),\r\n+        RangeSingle(:num value) => contains(value),\r\n+        RangeUnit() => !(this.start > other.end || this.end <= other.start),\r\n+        RangeEmpty() => false,\r\n+      };\r\n+\r\n+  @override\r\n+  Range difference(Range other) => !this.intersects(other)\r\n+      ? this\r\n+      : switch (other) {\r\n+          RangeUnion(:Set<RangeBase> ranges) =>\r\n+            ranges.fold(this, (Range self, RangeBase base) => self.difference(base)),\r\n+          RangeSingle(:num value) => RangeUnion(<RangeBase>{\r\n+              if (Range.unit(start, value) case RangeBase base) base,\r\n+              if (Range.unit(value, end) case RangeBase base) base,\r\n+            }),\r\n+          RangeUnit(:num start, :num end) => RangeUnion(<RangeBase>{\r\n+              if (Range.unit(math.min(this.start, start), start) case RangeBase base) base,\r\n+              if (Range.unit(end, math.max(this.end, end)) case RangeBase base) base,\r\n+              Range.single(start) as RangeBase,\r\n+              Range.single(end) as RangeBase,\r\n+            }),\r\n+          RangeEmpty() => this,\r\n+        };\r\n+\r\n+  @override\r\n+  Range intersection(Range other) =>\r\n+      switch (this.isEmpty || other.isEmpty || !this.intersects(other)) {\r\n+        true => const Range.empty(),\r\n+        false => switch (other) {\r\n+            RangeUnit(:num start, :num end) =>\r\n+              Range.unit(math.max(this.start, start), math.min(this.end, end)),\r\n+            RangeUnion(:Set<RangeBase> ranges) =>\r\n+              ranges.fold(this, (Range l, RangeBase r) => l.intersection(r)),\r\n+            RangeSingle() => this,\r\n+            RangeEmpty() => other,\r\n+          },\r\n+      };\r\n+\r\n+  @override\r\n+  Range union(Range other) {\r\n+    if (this.isEmpty) {\r\n+      return other;\r\n+    }\r\n+    if (other.isEmpty) {\r\n+      return this;\r\n+    }\r\n+\r\n+    if (!this.intersects(other)) {\r\n+      /// Since this doesn't intersect, then\r\n+\r\n+      return switch (other) {\r\n+        RangeUnion() => RangeUnion(<RangeBase>{this, ...other.ranges}),\r\n+        RangeBase() => RangeUnion(<RangeBase>{this, other}),\r\n+        RangeEmpty() => this,\r\n+      };\r\n+    } else {\r\n+      /// At this point, it's guaranteed to intersect somewhere.\r\n+      return switch (other) {\r\n+        RangeUnion() => other.ranges.fold(this, (Range l, RangeBase r) => l.union(r)),\r\n+        RangeUnit() => this.combination(other),\r\n+        RangeSingle() || RangeEmpty() => this,\r\n+      };\r\n+    }\r\n+  }\r\n+\r\n+  @override\r\n+  num get length => end - start;\r\n+\r\n+  @override\r\n+  String toString() => \"($start, $end)\";\r\n+}\r\n+\r\n+extension GlobalRangeExtension on Range {\r\n+  Range operator -(Range other) => this.difference(other);\r\n+  Range operator &(Range other) => this.intersection(other);\r\n+  Range operator |(Range other) => this.union(other);\r\n+\r\n+  bool get isEmpty => length == 0;\r\n+  bool get isNotEmpty => length != 0;\r\n+}\r\n"
                },
                {
                    "date": 1688899690161,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,4 +1,5 @@\n+import \"dart:io\";\r\n import \"dart:math\" as math;\r\n \r\n sealed class Range {\r\n   const factory Range.single(num value) = RangeSingle;\r\n@@ -100,343 +101,16 @@\n           switch (other) {\r\n             case RangeUnit(:num start, :num end) when socket.end == value && start == value:\r\n \r\n               /// We can match!\r\n-              /// We can match!\r\n               break;\r\n \r\n             case RangeUnit(:num start, :num end) when socket.start == value && end == value:\r\n-              break;\r\n \r\n-            case _:\r\n-              break;\r\n-          }\r\n-        }\r\n-      }\r\n-    }\r\n-\r\n-    return ranges.fold(other, (Range r, RangeBase unit) => unit.union(r));\r\n-  }\r\n-\r\n-  @override\r\n-  bool contains(Object? value) =>\r\n-      value is num && ranges.isNotEmpty && ranges.any((RangeBase u) => u.contains(value));\r\n-\r\n-  @override\r\n-  num get length => ranges.map((RangeBase u) => u.length).fold(0, (num a, num b) => a + b);\r\n-\r\n-  @override\r\n-  String toString() => isEmpty ? \"∅\" : ranges.join(\" | \");\r\n-}\r\n-\r\n-class RangeEmpty implements Range {\r\n-  const RangeEmpty();\r\n-\r\n-  @override\r\n-  bool contains(num value) => false;\r\n-\r\n-  @override\r\n-  bool covers(Range other) => other is RangeEmpty;\r\n-\r\n-  @override\r\n-  Range difference(Range other) => this;\r\n-\r\n-  @override\r\n-  Range intersection(Range other) => this;\r\n-\r\n-  @override\r\n-  bool intersects(Range other) => false;\r\n-\r\n-  @override\r\n-  Range union(Range other) => other;\r\n-\r\n-  @override\r\n-  int get length => 0;\r\n-\r\n-  @override\r\n-  String toString() => \"∅\";\r\n-}\r\n-\r\n-sealed class RangeBase implements Range {}\r\n-\r\n-final class RangeSingle implements RangeBase {\r\n-  const RangeSingle(this.value);\r\n-\r\n-  final num value;\r\n-\r\n-  @override\r\n-  bool contains(num value) => this.value == value;\r\n-\r\n-  @override\r\n-  bool covers(Range other) => other is RangeSingle && other.value == value;\r\n-\r\n-  @override\r\n-  Range difference(Range other) => switch (this.intersects(other)) {\r\n-        true => const Range.empty(),\r\n-        false => this,\r\n-      };\r\n-\r\n-  @override\r\n-  bool intersects(Range other) => switch (other) {\r\n-        RangeUnion(:Set<RangeBase> ranges) => ranges.any(this.intersects),\r\n-        RangeEmpty() => false,\r\n-        RangeSingle(:num value) => this.value == value,\r\n-        RangeUnit(:num start, :num end) => start < value && value < end,\r\n-      };\r\n-\r\n-  @override\r\n-  Range intersection(Range other) => switch (this.intersects(other)) {\r\n-        true => this,\r\n-        false => const Range.empty(),\r\n-      };\r\n-\r\n-  @override\r\n-  Range union(Range other) {\r\n-    if (other.isEmpty) {\r\n-      return this;\r\n-    }\r\n-\r\n-    if (!this.intersects(other)) {\r\n-      /// Since this doesn't intersect, then\r\n-\r\n-      return switch (other) {\r\n-        RangeUnion() => RangeUnion(<RangeBase>{this, ...other.ranges}),\r\n-        RangeBase() => RangeUnion(<RangeBase>{this, other}),\r\n-        RangeEmpty() => this,\r\n-      };\r\n-    }\r\n-\r\n-    /// At this point, it's guaranteed to intersect somewhere.\r\n-    return switch (other) {\r\n-      RangeUnion() => other.ranges.fold(this, (Range l, RangeBase r) => l.union(r)),\r\n-      RangeUnit() => other,\r\n-      RangeSingle() || RangeEmpty() => this,\r\n-    };\r\n-  }\r\n-\r\n-  @override\r\n-  num get length => 1;\r\n-\r\n-  @override\r\n-  String toString() => \"{$value}\";\r\n-}\r\n-\r\n-/// A closed interval between two, (min, max). Both are exclusive.\r\n-final class RangeUnit implements RangeBase {\r\n-  const RangeUnit(this.start, this.end);\r\n-\r\n-  final num start;\r\n-  final num end;\r\n-\r\n-  /// Returns the contingent combination of two [RangeUnit]s,\r\n-  ///   returning an equivalent [RangeUnit]\r\n-  Range combination(RangeUnit other) {\r\n-    num start = math.min(this.start, other.start);\r\n-    num end = math.max(this.end, other.end);\r\n-    if (start >= end) {\r\n-      return const Range.empty();\r\n-    }\r\n-\r\n-    return Range.unit(start, end);\r\n-  }\r\n-\r\n-  @override\r\n-  bool contains(num value) => start < value && value < end;\r\n-\r\n-  @override\r\n-  bool covers(Range other) => other is RangeSingle && contains(other.value);\r\n-\r\n-  @override\r\n-  bool intersects(Range other) => switch (other) {\r\n-        RangeUnion(:Set<RangeBase> ranges) => ranges.any(intersects),\r\n-        RangeSingle(:num value) => contains(value),\r\n-        RangeUnit() => !(this.start > other.end || this.end <= other.start),\r\n-        RangeEmpty() => false,\r\n-      };\r\n-\r\n-  @override\r\n-  Range difference(Range other) => !this.intersects(other)\r\n-      ? this\r\n-      : switch (other) {\r\n-          RangeUnion(:Set<RangeBase> ranges) =>\r\n-            ranges.fold(this, (Range self, RangeBase base) => self.difference(base)),\r\n-          RangeSingle(:num value) => RangeUnion(<RangeBase>{\r\n-              if (Range.unit(start, value) case RangeBase base) base,\r\n-              if (Range.unit(value, end) case RangeBase base) base,\r\n-            }),\r\n-          RangeUnit(:num start, :num end) => RangeUnion(<RangeBase>{\r\n-              if (Range.unit(math.min(this.start, start), start) case RangeBase base) base,\r\n-              if (Range.unit(end, math.max(this.end, end)) case RangeBase base) base,\r\n-              Range.single(start) as RangeBase,\r\n-              Range.single(end) as RangeBase,\r\n-            }),\r\n-          RangeEmpty() => this,\r\n-        };\r\n-\r\n-  @override\r\n-  Range intersection(Range other) =>\r\n-      switch (this.isEmpty || other.isEmpty || !this.intersects(other)) {\r\n-        true => const Range.empty(),\r\n-        false => switch (other) {\r\n-            RangeUnit(:num start, :num end) =>\r\n-              Range.unit(math.max(this.start, start), math.min(this.end, end)),\r\n-            RangeUnion(:Set<RangeBase> ranges) =>\r\n-              ranges.fold(this, (Range l, RangeBase r) => l.intersection(r)),\r\n-            RangeSingle() => this,\r\n-            RangeEmpty() => other,\r\n-          },\r\n-      };\r\n-\r\n-  @override\r\n-  Range union(Range other) {\r\n-    if (this.isEmpty) {\r\n-      return other;\r\n-    }\r\n-    if (other.isEmpty) {\r\n-      return this;\r\n-    }\r\n-\r\n-    if (!this.intersects(other)) {\r\n-      /// Since this doesn't intersect, then\r\n-\r\n-      return switch (other) {\r\n-        RangeUnion() => RangeUnion(<RangeBase>{this, ...other.ranges}),\r\n-        RangeBase() => RangeUnion(<RangeBase>{this, other}),\r\n-        RangeEmpty() => this,\r\n-      };\r\n-    } else {\r\n-      /// At this point, it's guaranteed to intersect somewhere.\r\n-      return switch (other) {\r\n-        RangeUnion() => other.ranges.fold(this, (Range l, RangeBase r) => l.union(r)),\r\n-        RangeUnit() => this.combination(other),\r\n-        RangeSingle() || RangeEmpty() => this,\r\n-      };\r\n-    }\r\n-  }\r\n-\r\n-  @override\r\n-  num get length => end - start;\r\n-\r\n-  @override\r\n-  String toString() => \"($start, $end)\";\r\n-}\r\n-\r\n-extension GlobalRangeExtension on Range {\r\n-  Range operator -(Range other) => this.difference(other);\r\n-  Range operator &(Range other) => this.intersection(other);\r\n-  Range operator |(Range other) => this.union(other);\r\n-\r\n-  bool get isEmpty => length == 0;\r\n-  bool get isNotEmpty => length != 0;\r\n-}\r\n-import \"dart:math\" as math;\r\n-\r\n-sealed class Range {\r\n-  const factory Range.single(num value) = RangeSingle;\r\n-  factory Range.unit(num start, num end) {\r\n-    if (end <= start) {\r\n-      return const Range.empty();\r\n-    }\r\n-    return RangeUnit(start, end);\r\n-  }\r\n-\r\n-  factory Range.union(Set<RangeUnit> units) {\r\n-    units = <RangeUnit>{\r\n-      for (RangeUnit unit in units)\r\n-        if (unit.isNotEmpty) unit,\r\n-    };\r\n-    if (units.isEmpty) {\r\n-      return const Range.empty();\r\n-    }\r\n-    return RangeUnion(units);\r\n-  }\r\n-\r\n-  const factory Range.empty() = RangeEmpty;\r\n-\r\n-  bool contains(num value);\r\n-\r\n-  /// Returns `true` if the [Range] `this` covers or is a superset of another [Range]\r\n-  bool covers(Range other);\r\n-\r\n-  /// Returns `true` if the [Range] intersects with another [Range].\r\n-  bool intersects(Range other);\r\n-\r\n-  /// Returns the difference of two ranges. If the rhs (right hand side) does not\r\n-  ///   intersect with the lhs (left hand side), then the lhs is returned unmodified.\r\n-  Range difference(Range other);\r\n-\r\n-  /// Returns the intersection (common element) of a range.\r\n-  Range intersection(Range other);\r\n-\r\n-  /// Returns the union of a range. It is not guaranteed to return a [RangeUnion].\r\n-  Range union(Range other);\r\n-\r\n-  /// Returns the length of the range.\r\n-  num get length;\r\n-}\r\n-\r\n-/// A union of range units or range singles.\r\n-final class RangeUnion implements Range {\r\n-  const RangeUnion(this.ranges);\r\n-\r\n-  final Set<RangeBase> ranges;\r\n-\r\n-  @override\r\n-  bool covers(Range other) => ranges.any((RangeBase r) => r.covers(other));\r\n-\r\n-  @override\r\n-  Range difference(Range other) {\r\n-    if (!this.intersects(other)) {\r\n-      return this;\r\n-    }\r\n-\r\n-    Set<RangeBase> units = <RangeBase>{};\r\n-    for (RangeBase unit in this.ranges) {\r\n-      switch (unit.difference(other)) {\r\n-        case RangeUnit difference when difference != const Range.empty():\r\n-          units.add(difference);\r\n-        case RangeUnion difference:\r\n-          units.addAll(difference.ranges);\r\n-        case RangeEmpty _:\r\n-        default:\r\n-          break;\r\n-      }\r\n-    }\r\n-\r\n-    return RangeUnion(units);\r\n-  }\r\n-\r\n-  @override\r\n-  Range intersection(Range other) =>\r\n-      ranges.fold(other, (Range r, RangeBase unit) => unit.intersection(r));\r\n-\r\n-  @override\r\n-  bool intersects(Range other) => ranges.any((RangeBase r) => r.intersects(other));\r\n-\r\n-  @override\r\n-  Range union(Range other) {\r\n-    /// If we have ((a, b) | b) | (b, d), then we can simplify it to (a, d);\r\n-    /// Cases:\r\n-    ///   [(a, b) | b] | (b, d) => (a, d)\r\n-    ///   [(a, b) | b] | [c | (b, d)] => (a, d)\r\n-    ///   [(a, b) | b] | [c | (b, d) | e] => (a, e)\r\n-    for (RangeSingle single in this.ranges.whereType<RangeSingle>()) {\r\n-      if (single case RangeSingle(:num value)) {\r\n-        RangeUnit? socket = ranges\r\n-            .whereType<RangeUnit>()\r\n-            .where((RangeUnit unit) => unit.start == value || unit.end == value)\r\n-            .firstOrNull;\r\n-\r\n-        if (socket != null) {\r\n-          switch (other) {\r\n-            case RangeUnit(:num start, :num end) when socket.end == value && start == value:\r\n-\r\n               /// We can match!\r\n+              stdout.writeln(\"We can match! $socket | $single | $other\");\r\n               break;\r\n \r\n-            case RangeUnit(:num start, :num end) when socket.start == value && end == value:\r\n-              break;\r\n-\r\n             case _:\r\n               break;\r\n           }\r\n         }\r\n@@ -634,9 +308,9 @@\n       };\r\n     } else {\r\n       /// At this point, it's guaranteed to intersect somewhere.\r\n       return switch (other) {\r\n-        RangeUnion() => other.ranges.fold(this, (RangeUni l, RangeBase r) => l.union(r)),\r\n+        RangeUnion() => other.ranges.fold(this, (Range l, RangeBase r) => l.union(r)),\r\n         RangeUnit() => this.combination(other),\r\n         RangeSingle() || RangeEmpty() => this,\r\n       };\r\n     }\r\n"
                },
                {
                    "date": 1688899751805,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -84,8 +84,9 @@\n   bool intersects(Range other) => ranges.any((RangeBase r) => r.intersects(other));\r\n \r\n   @override\r\n   Range union(Range other) {\r\n+    \r\n     /// If we have ((a, b) | b) | (b, d), then we can simplify it to (a, d);\r\n     /// Cases:\r\n     ///   [(a, b) | b] | (b, d) => (a, d)\r\n     ///   [(a, b) | b] | [c | (b, d)] => (a, d)\r\n@@ -101,8 +102,9 @@\n           switch (other) {\r\n             case RangeUnit(:num start, :num end) when socket.end == value && start == value:\r\n \r\n               /// We can match!\r\n+              stdout.writeln(\"We can match! $socket | $single | $other\");\r\n               break;\r\n \r\n             case RangeUnit(:num start, :num end) when socket.start == value && end == value:\r\n \r\n"
                },
                {
                    "date": 1688899783166,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -84,9 +84,9 @@\n   bool intersects(Range other) => ranges.any((RangeBase r) => r.intersects(other));\r\n \r\n   @override\r\n   Range union(Range other) {\r\n-    \r\n+\r\n     /// If we have ((a, b) | b) | (b, d), then we can simplify it to (a, d);\r\n     /// Cases:\r\n     ///   [(a, b) | b] | (b, d) => (a, d)\r\n     ///   [(a, b) | b] | [c | (b, d)] => (a, d)\r\n"
                },
                {
                    "date": 1688899814381,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -108,9 +108,8 @@\n \r\n             case RangeUnit(:num start, :num end) when socket.start == value && end == value:\r\n \r\n               /// We can match!\r\n-              stdout.writeln(\"We can match! $socket | $single | $other\");\r\n               break;\r\n \r\n             case _:\r\n               break;\r\n"
                },
                {
                    "date": 1688899854193,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -84,9 +84,8 @@\n   bool intersects(Range other) => ranges.any((RangeBase r) => r.intersects(other));\r\n \r\n   @override\r\n   Range union(Range other) {\r\n-\r\n     /// If we have ((a, b) | b) | (b, d), then we can simplify it to (a, d);\r\n     /// Cases:\r\n     ///   [(a, b) | b] | (b, d) => (a, d)\r\n     ///   [(a, b) | b] | [c | (b, d)] => (a, d)\r\n@@ -108,9 +107,9 @@\n \r\n             case RangeUnit(:num start, :num end) when socket.start == value && end == value:\r\n \r\n               /// We can match!\r\n-              break;\r\n+              return R;\r\n \r\n             case _:\r\n               break;\r\n           }\r\n"
                },
                {
                    "date": 1688899884948,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -107,9 +107,13 @@\n \r\n             case RangeUnit(:num start, :num end) when socket.start == value && end == value:\r\n \r\n               /// We can match!\r\n-              return R;\r\n+              return RangeUnion(<RangeBase>{\r\n+                RangeUnit(s),\r\n+                for (RangeBase base in ranges)\r\n+                  if (base != socket && base != single) base,\r\n+              });\r\n \r\n             case _:\r\n               break;\r\n           }\r\n"
                },
                {
                    "date": 1688899885139,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -108,9 +108,9 @@\n             case RangeUnit(:num start, :num end) when socket.start == value && end == value:\r\n \r\n               /// We can match!\r\n               return RangeUnion(<RangeBase>{\r\n-                RangeUnit(s),\r\n+                RangeUnit(star),\r\n                 for (RangeBase base in ranges)\r\n                   if (base != socket && base != single) base,\r\n               });\r\n \r\n"
                },
                {
                    "date": 1688899955683,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,5 +1,4 @@\n-import \"dart:io\";\r\n import \"dart:math\" as math;\r\n \r\n sealed class Range {\r\n   const factory Range.single(num value) = RangeSingle;\r\n@@ -101,18 +100,21 @@\n           switch (other) {\r\n             case RangeUnit(:num start, :num end) when socket.end == value && start == value:\r\n \r\n               /// We can match!\r\n-              stdout.writeln(\"We can match! $socket | $single | $other\");\r\n-              break;\r\n+              return RangeUnion(<RangeBase>{\r\n+                RangeUnit(socket.start, end),\r\n+                for (RangeBase base in ranges)\r\n+                  if (base != socket && base != single) base,\r\n+              });\r\n \r\n             case RangeUnit(:num start, :num end) when socket.start == value && end == value:\r\n \r\n               /// We can match!\r\n               return RangeUnion(<RangeBase>{\r\n-                RangeUnit(star),\r\n+                RangeUnit(start, socket.end),\r\n                 for (RangeBase base in ranges)\r\n-                  if (base != socket && base != single) base,\r\n+                  if () base,\r\n               });\r\n \r\n             case _:\r\n               break;\r\n"
                },
                {
                    "date": 1688900012155,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -112,15 +112,15 @@\n               /// We can match!\r\n               return RangeUnion(<RangeBase>{\r\n                 RangeUnit(start, socket.end),\r\n                 for (RangeBase base in ranges)\r\n-                  if () base,\r\n+                  if (base != socket && base != single) base,\r\n               });\r\n \r\n             case _:\r\n               break;\r\n           }\r\n-        }\r\n+        } \r\n       }\r\n     }\r\n \r\n     return ranges.fold(other, (Range r, RangeBase unit) => unit.union(r));\r\n"
                },
                {
                    "date": 1688900044308,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -118,9 +118,13 @@\n \r\n             case _:\r\n               break;\r\n           }\r\n-        } \r\n+        } else {\r\n+          if (other case RangeUnion(:Set<RangeBase> ranges)) {\r\n+            i\r\n+          }\r\n+        }\r\n       }\r\n     }\r\n \r\n     return ranges.fold(other, (Range r, RangeBase unit) => unit.union(r));\r\n"
                },
                {
                    "date": 1688900044466,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -120,9 +120,9 @@\n               break;\r\n           }\r\n         } else {\r\n           if (other case RangeUnion(:Set<RangeBase> ranges)) {\r\n-            if\r\n+            if \r\n           }\r\n         }\r\n       }\r\n     }\r\n"
                },
                {
                    "date": 1688900076168,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -120,9 +120,9 @@\n               break;\r\n           }\r\n         } else {\r\n           if (other case RangeUnion(:Set<RangeBase> ranges)) {\r\n-            if (ranges.whereType<RangeBase>().any(() => )){}\r\n+            if (ranges.whereType<RangeBase>().any((base) => )){}\r\n           }\r\n         }\r\n       }\r\n     }\r\n"
                }
            ],
            "date": 1688831182705,
            "name": "Commit-0",
            "content": "import \"dart:math\" as math;\r\n\r\nsealed class Range {\r\n  const factory Range.single(num value) = RangeSingle;\r\n  factory Range.unit(num start, num end) {\r\n    if (end <= start) {\r\n      return const Range.empty();\r\n    }\r\n    return RangeUnit(start, end);\r\n  }\r\n\r\n  factory Range.union(Set<RangeUnit> units) {\r\n    units = <RangeUnit>{\r\n      for (RangeUnit unit in units)\r\n        if (unit.isNotEmpty) unit,\r\n    };\r\n    if (units.isEmpty) {\r\n      return const Range.empty();\r\n    }\r\n    return RangeUnion(units);\r\n  }\r\n\r\n  const factory Range.empty() = RangeEmpty;\r\n\r\n  bool contains(num value);\r\n\r\n  /// Returns `true` if the [Range] `this` covers or is a superset of another [Range]\r\n  bool covers(Range other);\r\n\r\n  /// Returns `true` if the [Range] intersects with another [Range].\r\n  bool intersects(Range other);\r\n\r\n  /// Returns the difference of two ranges. If the rhs (right hand side) does not\r\n  ///   intersect with the lhs (left hand side), then the lhs is returned unmodified.\r\n  Range difference(Range other);\r\n\r\n  /// Returns the intersection (common element) of a range.\r\n  Range intersection(Range other);\r\n\r\n  /// Returns the union of a range. It is not guaranteed to return a [RangeUnion].\r\n  Range union(Range other);\r\n\r\n  /// Returns the length of the range.\r\n  num get length;\r\n}\r\n\r\n/// A union of range units or range singles.\r\nfinal class RangeUnion implements Range {\r\n  const RangeUnion(this.ranges);\r\n\r\n  final Set<RangeBase> ranges;\r\n\r\n  @override\r\n  bool covers(Range other) => ranges.any((RangeBase r) => r.covers(other));\r\n\r\n  @override\r\n  Range difference(Range other) {\r\n    if (!this.intersects(other)) {\r\n      return this;\r\n    }\r\n\r\n    Set<RangeBase> units = <RangeBase>{};\r\n    for (RangeBase unit in this.ranges) {\r\n      switch (unit.difference(other)) {\r\n        case RangeUnit difference when difference != const Range.empty():\r\n          units.add(difference);\r\n        case RangeUnion difference:\r\n          units.addAll(difference.ranges);\r\n        case RangeEmpty _:\r\n        default:\r\n          break;\r\n      }\r\n    }\r\n\r\n    return RangeUnion(units);\r\n  }\r\n\r\n  @override\r\n  Range intersection(Range other) =>\r\n      ranges.fold(other, (Range r, RangeBase unit) => unit.intersection(r));\r\n\r\n  @override\r\n  bool intersects(Range other) => ranges.any((RangeBase r) => r.intersects(other));\r\n\r\n  @override\r\n  Range union(Range other) => ranges.fold(other, (Range r, RangeBase unit) => unit.union(r));\r\n\r\n  @override\r\n  bool contains(Object? value) =>\r\n      value is num && ranges.isNotEmpty && ranges.any((RangeBase u) => u.contains(value));\r\n\r\n  @override\r\n  num get length => ranges.map((RangeBase u) => u.length).fold(0, (num a, num b) => a + b);\r\n\r\n  @override\r\n  String toString() => isEmpty ? \"∅\" : ranges.join(\" | \");\r\n}\r\n\r\nclass RangeEmpty implements Range {\r\n  const RangeEmpty();\r\n\r\n  @override\r\n  bool contains(num value) => false;\r\n\r\n  @override\r\n  bool covers(Range other) => other is RangeEmpty;\r\n\r\n  @override\r\n  Range difference(Range other) => this;\r\n\r\n  @override\r\n  Range intersection(Range other) => this;\r\n\r\n  @override\r\n  bool intersects(Range other) => false;\r\n\r\n  @override\r\n  Range union(Range other) => other;\r\n\r\n  @override\r\n  int get length => 0;\r\n\r\n  @override\r\n  String toString() => \"∅\";\r\n}\r\n\r\nsealed class RangeBase implements Range {}\r\n\r\nfinal class RangeSingle implements RangeBase {\r\n  const RangeSingle(this.value);\r\n\r\n  final num value;\r\n\r\n  @override\r\n  bool contains(num value) => this.value == value;\r\n\r\n  @override\r\n  bool covers(Range other) => other is RangeSingle && other.value == value;\r\n\r\n  @override\r\n  Range difference(Range other) => switch (this.intersects(other)) {\r\n        true => const Range.empty(),\r\n        false => this,\r\n      };\r\n\r\n  @override\r\n  bool intersects(Range other) => switch (other) {\r\n        RangeUnion(:Set<RangeBase> ranges) => ranges.any(this.intersects),\r\n        RangeEmpty() => false,\r\n        RangeSingle(:num value) => this.value == value,\r\n        RangeUnit(:num start, :num end) => start < value && value < end,\r\n      };\r\n\r\n  @override\r\n  Range intersection(Range other) => switch (this.intersects(other)) {\r\n        true => this,\r\n        false => const Range.empty(),\r\n      };\r\n\r\n  @override\r\n  Range union(Range other) {\r\n    if (other.isEmpty) {\r\n      return this;\r\n    }\r\n\r\n    if (!this.intersects(other)) {\r\n      /// Since this doesn't intersect, then\r\n\r\n      return switch (other) {\r\n        RangeUnion() => RangeUnion(<RangeBase>{this, ...other.ranges}),\r\n        RangeBase() => RangeUnion(<RangeBase>{this, other}),\r\n        RangeEmpty() => this,\r\n      };\r\n    }\r\n\r\n    /// At this point, it's guaranteed to intersect somewhere.\r\n    return switch (other) {\r\n      RangeUnion() => other.ranges.fold(this, (Range l, RangeBase r) => l.union(r)),\r\n      RangeUnit() => other,\r\n      RangeSingle() || RangeEmpty() => this,\r\n    };\r\n  }\r\n\r\n  @override\r\n  num get length => 1;\r\n\r\n  @override\r\n  String toString() => \"{$value}\";\r\n}\r\n\r\n/// A closed interval between two, (min, max). Both are exclusive.\r\nfinal class RangeUnit implements RangeBase {\r\n  const RangeUnit(this.start, this.end);\r\n\r\n  final num start;\r\n  final num end;\r\n\r\n  /// Returns the contingent combination of two [RangeUnit]s,\r\n  ///   returning an equivalent [RangeUnit]\r\n  Range combination(RangeUnit other) {\r\n    num start = math.min(this.start, other.start);\r\n    num end = math.max(this.end, other.end);\r\n    if (start >= end) {\r\n      return const Range.empty();\r\n    }\r\n\r\n    return Range.unit(start, end);\r\n  }\r\n\r\n  @override\r\n  bool contains(num value) => start < value && value < end;\r\n\r\n  @override\r\n  bool covers(Range other) => other is RangeSingle && contains(other.value);\r\n\r\n  @override\r\n  bool intersects(Range other) => switch (other) {\r\n        RangeUnion(:Set<RangeBase> ranges) => ranges.any(intersects),\r\n        RangeSingle(:num value) => contains(value),\r\n        RangeUnit() => !(this.start > other.end || this.end <= other.start),\r\n        RangeEmpty() => false,\r\n      };\r\n\r\n  @override\r\n  Range difference(Range other) => !this.intersects(other)\r\n      ? this\r\n      : switch (other) {\r\n          RangeUnion(:Set<RangeBase> ranges) =>\r\n            ranges.fold(this, (Range self, RangeBase base) => self.difference(base)),\r\n          RangeSingle(:num value) => RangeUnion(<RangeBase>{\r\n              if (Range.unit(start, value) case RangeBase base) base,\r\n              if (Range.unit(value, end) case RangeBase base) base,\r\n            }),\r\n          RangeUnit(:num start, :num end) => RangeUnion(<RangeBase>{\r\n              if (Range.unit(math.min(this.start, start), start) case RangeBase base) base,\r\n              if (Range.unit(end, math.max(this.end, end)) case RangeBase base) base,\r\n              Range.single(start) as RangeBase,\r\n              Range.single(end) as RangeBase,\r\n            }),\r\n          RangeEmpty() => this,\r\n        };\r\n\r\n  @override\r\n  Range intersection(Range other) =>\r\n      switch (this.isEmpty || other.isEmpty || !this.intersects(other)) {\r\n        true => const Range.empty(),\r\n        false => switch (other) {\r\n            RangeUnit(:num start, :num end) =>\r\n              Range.unit(math.max(this.start, start), math.min(this.end, end)),\r\n            RangeUnion(:Set<RangeBase> ranges) =>\r\n              ranges.fold(this, (Range l, RangeBase r) => l.intersection(r)),\r\n            RangeSingle() => this,\r\n            RangeEmpty() => other,\r\n          },\r\n      };\r\n\r\n  @override\r\n  Range union(Range other) {\r\n    if (this.isEmpty) {\r\n      return other;\r\n    }\r\n    if (other.isEmpty) {\r\n      return this;\r\n    }\r\n\r\n    if (!this.intersects(other)) {\r\n      /// Since this doesn't intersect, then\r\n\r\n      return switch (other) {\r\n        RangeUnion() => RangeUnion(<RangeBase>{this, ...other.ranges}),\r\n        RangeBase() => RangeUnion(<RangeBase>{this, other}),\r\n        RangeEmpty() => this,\r\n      };\r\n    }\r\n\r\n    /// At this point, it's guaranteed to intersect somewhere.\r\n    return switch (other) {\r\n      RangeUnion() => other.ranges.fold(this, (Range l, RangeBase r) => l.union(r)),\r\n      RangeUnit() => this.combination(other),\r\n      RangeSingle() || RangeEmpty() => this,\r\n    };\r\n  }\r\n\r\n  @override\r\n  num get length => end - start;\r\n\r\n  @override\r\n  String toString() => \"($start, $end)\";\r\n}\r\n\r\nextension GlobalRangeExtension on Range {\r\n  Range operator -(Range other) => this.difference(other);\r\n  Range operator &(Range other) => this.intersection(other);\r\n  Range operator |(Range other) => this.union(other);\r\n\r\n  bool get isEmpty => length == 0;\r\n  bool get isNotEmpty => length != 0;\r\n}\r\n"
        }
    ]
}