{
    "sourceFile": "bin/previous/matrix.dart",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 1,
            "patches": [
                {
                    "date": 1691774743039,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1698396747310,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -198,9 +198,9 @@\n     if (determinant == null) {\r\n       return null;\r\n     }\r\n \r\n-    Matrix<num?> cof.actorMatrix = <List<num?>>[\r\n+    Matrix<num?> cofactorMatrix = <List<num?>>[\r\n       for (int y = 0; y < verticalLength; y++)\r\n         <num?>[\r\n           for (int x = 0; x < horizontalLength; x++) //\r\n             removed(x: <int>{x}, y: <int>{y}).determinant\r\n"
                }
            ],
            "date": 1691774743039,
            "name": "Commit-0",
            "content": "import \"dart:math\" as math;\r\n\r\ntypedef Matrix<T> = List<List<T>>;\r\n\r\nextension VectorExtension<E extends num> on List<E> {\r\n  num? operator *(List<num> right) => //\r\n      0\r\n          .to(math.min(length, right.length))\r\n          .map((int index) => this[index] * right[index])\r\n          .reduce((num value, num element) => value + element);\r\n}\r\n\r\nextension IterableExtension on int {\r\n  Iterable<int> to(int end) sync* {\r\n    for (int i = this; i < end; i++) {\r\n      yield i;\r\n    }\r\n  }\r\n}\r\n\r\nextension MatrixMethods<E> on Matrix<E> {\r\n  Map<String, int> get dimensions => <String, int>{\"x\": horizontalLength, \"y\": verticalLength};\r\n\r\n  Matrix<E> get columns => transpose();\r\n  Matrix<E> get rows => this;\r\n\r\n  Matrix<E> removeColumnsWhereEvery(bool Function(E) handler) => //\r\n      transpose().removeRowsWhereEvery(handler).transpose();\r\n\r\n  Matrix<E> removeRowsWhereEvery(bool Function(E) handler) => //\r\n      where((List<E> item) => !item.every(handler)).toList();\r\n\r\n  Matrix<E> submatrix({int top = 0, int bottom = 0, int left = 0, int right = 0}) => <List<E>>[\r\n        for (int y = top; y < length - bottom; y++) //\r\n          <E>[for (int x = left; x < this[y].length - right; x++) this[y][x]]\r\n      ];\r\n\r\n  Matrix<E> removed({Set<int> x = const <int>{}, Set<int> y = const <int>{}}) => <List<E>>[\r\n        for (int _y = 0; _y < verticalLength; _y++)\r\n          if (!y.contains(_y))\r\n            <E>[\r\n              for (int _x = 0; _x < horizontalLength; _x++)\r\n                if (!x.contains(_x)) this[_y][_x]\r\n            ]\r\n      ];\r\n\r\n  Matrix<E> transpose() => <List<E>>[\r\n        for (int y = 0; y < verticalLength; y++) //\r\n          <E>[for (int x = 0; x < horizontalLength; x++) this[x][y]]\r\n      ];\r\n\r\n  Matrix<E> expandColumn(int at, List<E> Function(E element) handler, {E? filler}) {\r\n    Matrix<E> expanded = <List<E>>[for (int i = 0; i < length; i++) handler(this[i][at])];\r\n    Set<int> resultLengths = expanded.map((List<E> list) => list.length).toSet();\r\n    if (filler == null && resultLengths.length > 1) {\r\n      throw StateError(\"The resulting matrix shape is uneven and there was no filler provided.\");\r\n    }\r\n\r\n    int max = resultLengths.reduce(math.max);\r\n    Matrix<E> filled = <List<E>>[\r\n      for (List<E> row in expanded)\r\n        <E>[\r\n          ...row,\r\n          if (filler != null)\r\n            for (int i = row.length; i < max; i++) filler\r\n        ]\r\n    ];\r\n    Matrix<E> matrix = <List<E>>[\r\n      for (int i = 0; i < length; i++)\r\n        <E>[\r\n          for (int j = 0; j < this[i].length; j++)\r\n            if (j == at) ...filled[i] else this[i][j]\r\n        ]\r\n    ];\r\n\r\n    return matrix;\r\n  }\r\n\r\n  // I got lazy lmao\r\n  Matrix<E> expandRow(int index, List<E> Function(E element) handler, {E? filler}) =>\r\n      transpose().expandColumn(index, handler, filler: filler).transpose();\r\n\r\n  Matrix<E> mapColumn(int index, E Function(E element) handler) => <List<E>>[\r\n        for (List<E> row in this)\r\n          <E>[\r\n            for (int i = 0; i < row.length; i++)\r\n              if (i == index) handler(row[i]) else row[i]\r\n          ],\r\n      ];\r\n\r\n  Matrix<E> mapRow<R extends E>(int index, E Function(E element) handler) => <List<E>>[\r\n        for (int i = 0; i < length; i++)\r\n          <E>[\r\n            for (E item in this[i])\r\n              if (i == index) handler(item) else item\r\n          ],\r\n      ];\r\n\r\n  Matrix<R> matrixMap<R>(R Function(E element) handler) =>\r\n      map((List<E> row) => row.map((E item) => handler(item)).toList()).toList();\r\n\r\n  int get verticalLength => length;\r\n  int get horizontalLength => _safeLength;\r\n\r\n  int get _safeLength => map((List<E> row) => row.length).reduce(math.min);\r\n\r\n  String toMatrixString() => str;\r\n  String toCsvString() => csv;\r\n\r\n  String get str {\r\n    List<int> profile = transpose() //\r\n        .map((List<E> c) => c.map((E element) => \"$element\".length).reduce(math.max))\r\n        .toList();\r\n\r\n    StringBuffer buffer = StringBuffer();\r\n    for (List<String> row in matrixMap((E element) => element.toString())) {\r\n      for (int i = 0; i < row.length; i++) {\r\n        buffer.write(\"${row[i]}${\" \" * (profile[i] - row[i].length)} \");\r\n      }\r\n      buffer.writeln();\r\n    }\r\n\r\n    return buffer.toString();\r\n  }\r\n\r\n  String get csv {\r\n    List<int> profile = transpose() //\r\n        .map((List<E> rows) => rows.map((E element) => \"$element\".length).reduce(math.max))\r\n        .toList();\r\n\r\n    StringBuffer buffer = StringBuffer();\r\n    for (List<E> row in this) {\r\n      for (int i = 0; i < row.length; i++) {\r\n        String cell = row[i].toString();\r\n        String toWrite = i + 1 < row.length //\r\n            ? \"$cell${\" \" * (profile[i] - cell.length)},\"\r\n            : cell;\r\n\r\n        buffer.write(toWrite);\r\n      }\r\n      buffer.writeln();\r\n    }\r\n\r\n    return buffer.toString();\r\n  }\r\n}\r\n\r\nextension on num {\r\n  num fix() => this < 1e-12\r\n      ? 0\r\n      : this - roundToDouble() < 1e-12\r\n          ? roundToDouble()\r\n          : this;\r\n}\r\n\r\nextension MathematicalMatrix<E extends num> on Matrix<E> {\r\n  // This is O(n!). Change this to O(n^3) (LU Factorization) later.\r\n  num? get determinant {\r\n    if (verticalLength != horizontalLength) {\r\n      return null;\r\n    }\r\n\r\n    if (verticalLength == 1) {\r\n      return this[0][0];\r\n    }\r\n\r\n    num sum = 0;\r\n    for (int x = 0; x < horizontalLength; x++) {\r\n      Matrix<E> submatrix = removed(y: <int>{0}, x: <int>{x});\r\n      num determinant = submatrix.determinant!;\r\n      num multiplier = math.pow(-1, 0 /* row */ + x /* column */);\r\n      num cell = this[0][x];\r\n\r\n      sum += cell * multiplier * determinant;\r\n    }\r\n\r\n    return sum;\r\n  }\r\n\r\n  String get str {\r\n    List<int> profile = transpose() //\r\n        .map((List<E> c) => c.map((E element) => \"$element\".length).reduce(math.max))\r\n        .toList();\r\n\r\n    StringBuffer buffer = StringBuffer();\r\n    for (List<String> row in matrixMap((E element) => \"$element\")) {\r\n      for (int i = 0; i < row.length; i++) {\r\n        buffer.write(\"${\" \" * (profile[i] - row[i].length)}${row[i]} \");\r\n      }\r\n      buffer.writeln();\r\n    }\r\n\r\n    return buffer.toString();\r\n  }\r\n\r\n  Matrix<num>? get inverse {\r\n    num? determinant = this.determinant;\r\n    if (determinant == null) {\r\n      return null;\r\n    }\r\n\r\n    Matrix<num?> cof.actorMatrix = <List<num?>>[\r\n      for (int y = 0; y < verticalLength; y++)\r\n        <num?>[\r\n          for (int x = 0; x < horizontalLength; x++) //\r\n            removed(x: <int>{x}, y: <int>{y}).determinant\r\n        ],\r\n    ];\r\n    if (cofactorMatrix.any((List<num?> r) => r.any((num? e) => e == null))) {\r\n      return null;\r\n    }\r\n\r\n    Matrix<num> adjoint = <List<num>>[\r\n      for (int y = 0; y < verticalLength; y++)\r\n        <num>[\r\n          for (int x = 0; x < horizontalLength; x++) //\r\n            math.pow(-1, x + y) * cofactorMatrix[x][y]!\r\n        ],\r\n    ];\r\n\r\n    return adjoint / determinant;\r\n  }\r\n\r\n  Matrix<num>? matrixMultiply(Matrix<num> other) {\r\n    Matrix<num> transmuted = other.transpose();\r\n    if (horizontalLength != transmuted.horizontalLength) {\r\n      return null;\r\n    }\r\n\r\n    Matrix<num> applied = map(\r\n      (List<num> r) => transmuted //\r\n          .map((List<num> t) => (r * t)!.fix())\r\n          .toList(), //\r\n    ).toList();\r\n\r\n    return applied;\r\n  }\r\n\r\n  num call(int y, int x) => this[y][x];\r\n\r\n  Matrix<num>? operator *(Object other) => other is num\r\n      ? matrixMap((num e) => e * other)\r\n      : other is Matrix<num>\r\n          ? matrixMultiply(other)\r\n          : null;\r\n\r\n  Matrix<num>? operator /(Object other) => other is num\r\n      ? matrixMap((num e) => e / other)\r\n      : other is Matrix<num>\r\n          ? ((Matrix<num>? inverse) => inverse == null ? null : matrixMultiply(inverse))(other.inverse)\r\n          : null;\r\n\r\n  Matrix<num>? operator ~/(Object other) => other is num //\r\n      ? matrixMap((num e) => e ~/ other)\r\n      : (this / other)?.matrixMap((num e) => e.floor());\r\n}\r\n"
        }
    ]
}