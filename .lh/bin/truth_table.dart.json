{
    "sourceFile": "bin/truth_table.dart",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 30,
            "patches": [
                {
                    "date": 1698380991998,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1698381024901,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,207 +1,209 @@\n-const IDENTIFIER = /^\\s*(?!not|and|xor|or)([A-Za-z_$][0-9A-Za-z_$]*)(.*)$/;\r\n-const L_PAREN = /^\\s*(\\()(.*)$/;\r\n-const R_PAREN = /^\\s*(\\))(.*)$/;\r\n-const NOT = /^\\s*(!|not)(.*)$/;\r\n-const AND = /^\\s*(&|and)(.*)$/;\r\n-const XOR = /^\\s*(\\^|xor)(.*)$/;\r\n-const OR = /^\\s*(\\||or)(.*)$/;\r\n \r\n-const parse = (input) => {\r\n-  const binary = (previous, regex, operator) => {\r\n-    return (input) => {\r\n-      let [left, err0, rest] = previous(input);\r\n-      if (err0 != null) {\r\n-        return [null, err0, rest];\r\n-      }\r\n \r\n-      let values = left;\r\n-      let match;\r\n-      while ((match = regex.exec(rest))) {\r\n-        const [right, err1, innerRest] = previous(match[2]);\r\n-        if (err1 != null) {\r\n-          return [null, err1, rest];\r\n-        }\r\n+const IDENTIFIER = r\"^\\s*(?!not|and|xor|or)([A-Za-z_$][0-9A-Za-z_$]*)(.*)\\$\";\r\n+const L_PAREN = r\"^\\s*(\\()(.*)\\$\";\r\n+const R_PAREN = r\"^\\s*(\\))(.*)\\$\";\r\n+const NOT = r\"^\\s*(!|not)(.*)\\$\";\r\n+const AND = r\"^\\s*(&|and)(.*)\\$\";\r\n+const XOR = r\"^\\s*(\\^|xor)(.*)\\$\";\r\n+const OR = r\"^\\s*(\\||or)(.*)\\$\";\r\n \r\n-        values = wrap([values, operator, right]);\r\n-        rest = innerRest;\r\n-      }\r\n+// const parse = (input) => {\r\n+//   const binary = (previous, regex, operator) => {\r\n+//     return (input) => {\r\n+//       let [left, err0, rest] = previous(input);\r\n+//       if (err0 != null) {\r\n+//         return [null, err0, rest];\r\n+//       }\r\n \r\n-      if (values.length <= 1) {\r\n-        return [values[0], null, rest];\r\n-      }\r\n-      return [values, null, rest];\r\n-    };\r\n-  };\r\n+//       let values = left;\r\n+//       let match;\r\n+//       while ((match = regex.exec(rest))) {\r\n+//         const [right, err1, innerRest] = previous(match[2]);\r\n+//         if (err1 != null) {\r\n+//           return [null, err1, rest];\r\n+//         }\r\n \r\n-  // deno-lint-ignore prefer-const\r\n-  let parseAtomic, parseUnary, parseAnd, parseXor, parseOr;\r\n+//         values = wrap([values, operator, right]);\r\n+//         rest = innerRest;\r\n+//       }\r\n \r\n-  parseAtomic = (input) => {\r\n-    let match;\r\n-    if ((match = IDENTIFIER.exec(input))) {\r\n-      return [match[1], null, match[2]];\r\n-    } else if ((match = L_PAREN.exec(input))) {\r\n-      const [inner, err, rest] = parseOr(match[2]);\r\n-      if (err != null) {\r\n-        return [null, err, rest];\r\n-      }\r\n+//       if (values.length <= 1) {\r\n+//         return [values[0], null, rest];\r\n+//       }\r\n+//       return [values, null, rest];\r\n+//     };\r\n+//   };\r\n \r\n-      if ((match = R_PAREN.exec(rest))) {\r\n-        return [wrap(inner), null, match[2]];\r\n-      } else {\r\n-        return [null, `Unterminated ')' at \"${rest}\" from \"${input}\"`, rest];\r\n-      }\r\n-    }\r\n-    return [null, `Cannot parse atomic at input: \"${input}\"`];\r\n-  };\r\n+//   // deno-lint-ignore prefer-const\r\n+//   let parseAtomic, parseUnary, parseAnd, parseXor, parseOr;\r\n \r\n-  parseUnary = (input) => {\r\n-    let match;\r\n-    if ((match = NOT.exec(input))) {\r\n-      const [inner, err, rest] = parseAtomic(match[2]);\r\n-      if (err == null) {\r\n-        return [[`~`, inner], null, rest];\r\n-      }\r\n-    } else {\r\n-      return parseAtomic(input);\r\n-    }\r\n-  };\r\n+//   parseAtomic = (input) => {\r\n+//     let match;\r\n+//     if ((match = IDENTIFIER.exec(input))) {\r\n+//       return [match[1], null, match[2]];\r\n+//     } else if ((match = L_PAREN.exec(input))) {\r\n+//       const [inner, err, rest] = parseOr(match[2]);\r\n+//       if (err != null) {\r\n+//         return [null, err, rest];\r\n+//       }\r\n \r\n-  parseAnd = binary(parseUnary, AND, \"&\");\r\n-  parseXor = binary(parseAnd, XOR, \"^\");\r\n-  parseOr = binary(parseXor, OR, \"|\");\r\n+//       if ((match = R_PAREN.exec(rest))) {\r\n+//         return [wrap(inner), null, match[2]];\r\n+//       } else {\r\n+//         return [null, `Unterminated ')' at \"${rest}\" from \"${input}\"`, rest];\r\n+//       }\r\n+//     }\r\n+//     return [null, `Cannot parse atomic at input: \"${input}\"`];\r\n+//   };\r\n \r\n-  const [result, error, _] = parseOr(input);\r\n+//   parseUnary = (input) => {\r\n+//     let match;\r\n+//     if ((match = NOT.exec(input))) {\r\n+//       const [inner, err, rest] = parseAtomic(match[2]);\r\n+//       if (err == null) {\r\n+//         return [[`~`, inner], null, rest];\r\n+//       }\r\n+//     } else {\r\n+//       return parseAtomic(input);\r\n+//     }\r\n+//   };\r\n \r\n-  if (error != null) {\r\n-    throw new Error(error);\r\n-  }\r\n+//   parseAnd = binary(parseUnary, AND, \"&\");\r\n+//   parseXor = binary(parseAnd, XOR, \"^\");\r\n+//   parseOr = binary(parseXor, OR, \"|\");\r\n \r\n-  return unwrap(result);\r\n-};\r\n+//   const [result, error, _] = parseOr(input);\r\n \r\n-const matchNode = (node, { parenthesis, binary, unary, atomic }) => {\r\n-  if (node instanceof Array) {\r\n-    if (node.length === 3) {\r\n-      const [left, mid, right] = node;\r\n+//   if (error != null) {\r\n+//     throw new Error(error);\r\n+//   }\r\n \r\n-      if (left == \"(\" && right == \")\") {\r\n-        return parenthesis(left, mid, right);\r\n-      } else {\r\n-        return binary(left, mid, right);\r\n-      }\r\n-    } else if (node.length == 2) {\r\n-      const [op, value] = node;\r\n+//   return unwrap(result);\r\n+// };\r\n \r\n-      return unary(op, value);\r\n-    }\r\n-  } else {\r\n-    return atomic(node);\r\n-  }\r\n-};\r\n+// const matchNode = (node, { parenthesis, binary, unary, atomic }) => {\r\n+//   if (node instanceof Array) {\r\n+//     if (node.length === 3) {\r\n+//       const [left, mid, right] = node;\r\n \r\n-const evaluate = (node, env) => {\r\n-  if (env.has(node)) {\r\n-    return env.get(node);\r\n-  }\r\n+//       if (left == \"(\" && right == \")\") {\r\n+//         return parenthesis(left, mid, right);\r\n+//       } else {\r\n+//         return binary(left, mid, right);\r\n+//       }\r\n+//     } else if (node.length == 2) {\r\n+//       const [op, value] = node;\r\n \r\n-  matchNode(node, {\r\n-    parenthesis: (_, mid, __) => env.set(node, evaluate(mid, env)),\r\n-    binary: (left, mid, right) => {\r\n-      if (mid === `&`) {\r\n-        env.set(node, evaluate(left, env) & evaluate(right, env));\r\n-      } else if (mid === \"|\") {\r\n-        env.set(node, evaluate(left, env) | evaluate(right, env));\r\n-      } else if (mid === `^`) {\r\n-        env.set(node, evaluate(left, env) ^ evaluate(right, env));\r\n-      } else {\r\n-        throw new Error(`Unknown operator ${mid}`);\r\n-      }\r\n-    },\r\n-    unary: (op, value) => {\r\n-      if (op == `~`) {\r\n-        env.set(node, 1 ^ evaluate(value, env));\r\n-      } else {\r\n-        throw new Error(`Unknown unary operator ${op}`);\r\n-      }\r\n-    },\r\n-    atomic: (node) => {\r\n-      console.log(node);\r\n-      if (!env.has(node)) {\r\n-        throw new Error(`Value ${node} is not defined!`);\r\n-      }\r\n-    },\r\n-  });\r\n-  return env.get(node);\r\n-};\r\n-const wrap = (node) => {\r\n-  if (node instanceof Array && node[0] == \"(\" && node[2] == \")\") {\r\n-    return node;\r\n-  }\r\n-  return [\"(\", node, \")\"];\r\n-};\r\n-const unwrap = (node) => {\r\n-  if (node instanceof Array && node[0] == \"(\" && node[2] == \")\") {\r\n-    return node[1];\r\n-  }\r\n+//       return unary(op, value);\r\n+//     }\r\n+//   } else {\r\n+//     return atomic(node);\r\n+//   }\r\n+// };\r\n \r\n-  return node;\r\n-};\r\n+// const evaluate = (node, env) => {\r\n+//   if (env.has(node)) {\r\n+//     return env.get(node);\r\n+//   }\r\n \r\n-const variables = (node) => {\r\n-  return matchNode(node, {\r\n-    parenthesis: (_, mid, __) => variables(mid),\r\n-    binary: (left, _, right) => [...variables(left), ...variables(right)],\r\n-    unary: (_, value) => [...variables(value)],\r\n-    atomic: (node) => [node],\r\n-  });\r\n-};\r\n+//   matchNode(node, {\r\n+//     parenthesis: (_, mid, __) => env.set(node, evaluate(mid, env)),\r\n+//     binary: (left, mid, right) => {\r\n+//       if (mid === `&`) {\r\n+//         env.set(node, evaluate(left, env) & evaluate(right, env));\r\n+//       } else if (mid === \"|\") {\r\n+//         env.set(node, evaluate(left, env) | evaluate(right, env));\r\n+//       } else if (mid === `^`) {\r\n+//         env.set(node, evaluate(left, env) ^ evaluate(right, env));\r\n+//       } else {\r\n+//         throw new Error(`Unknown operator ${mid}`);\r\n+//       }\r\n+//     },\r\n+//     unary: (op, value) => {\r\n+//       if (op == `~`) {\r\n+//         env.set(node, 1 ^ evaluate(value, env));\r\n+//       } else {\r\n+//         throw new Error(`Unknown unary operator ${op}`);\r\n+//       }\r\n+//     },\r\n+//     atomic: (node) => {\r\n+//       console.log(node);\r\n+//       if (!env.has(node)) {\r\n+//         throw new Error(`Value ${node} is not defined!`);\r\n+//       }\r\n+//     },\r\n+//   });\r\n+//   return env.get(node);\r\n+// };\r\n+// const wrap = (node) => {\r\n+//   if (node instanceof Array && node[0] == \"(\" && node[2] == \")\") {\r\n+//     return node;\r\n+//   }\r\n+//   return [\"(\", node, \")\"];\r\n+// };\r\n+// const unwrap = (node) => {\r\n+//   if (node instanceof Array && node[0] == \"(\" && node[2] == \")\") {\r\n+//     return node[1];\r\n+//   }\r\n \r\n-const truthValues = (node) => {\r\n-  const vars = variables(node);\r\n-  const result = [];\r\n+//   return node;\r\n+// };\r\n \r\n-  const permute = function* (n) {\r\n-    if (n <= 0) {\r\n-      yield [];\r\n-      return;\r\n-    }\r\n+// const variables = (node) => {\r\n+//   return matchNode(node, {\r\n+//     parenthesis: (_, mid, __) => variables(mid),\r\n+//     binary: (left, _, right) => [...variables(left), ...variables(right)],\r\n+//     unary: (_, value) => [...variables(value)],\r\n+//     atomic: (node) => [node],\r\n+//   });\r\n+// };\r\n \r\n-    for (const permutations of permute(n - 1)) {\r\n-      yield [0, ...permutations];\r\n-      yield [1, ...permutations];\r\n-    }\r\n-  };\r\n+// const truthValues = (node) => {\r\n+//   const vars = variables(node);\r\n+//   const result = [];\r\n \r\n-  for (const startingValues of permute(vars.length)) {\r\n-    const map = new Map(startingValues.map((v, i) => [vars[i], v]));\r\n+//   const permute = function* (n) {\r\n+//     if (n <= 0) {\r\n+//       yield [];\r\n+//       return;\r\n+//     }\r\n \r\n-    result.push(map);\r\n-  }\r\n+//     for (const permutations of permute(n - 1)) {\r\n+//       yield [0, ...permutations];\r\n+//       yield [1, ...permutations];\r\n+//     }\r\n+//   };\r\n \r\n-  return result;\r\n-};\r\n+//   for (const startingValues of permute(vars.length)) {\r\n+//     const map = new Map(startingValues.map((v, i) => [vars[i], v]));\r\n \r\n-const truthTable = (node) => {\r\n-  const results = [];\r\n+//     result.push(map);\r\n+//   }\r\n \r\n-  const str = (v) =>\r\n-    v instanceof Array //\r\n-      ? v.map(str).join(\" \")\r\n-      : v.toString();\r\n+//   return result;\r\n+// };\r\n \r\n-  for (const env of truthValues(node)) {\r\n-    evaluate(node, env);\r\n+// const truthTable = (node) => {\r\n+//   const results = [];\r\n \r\n-    const values = {};\r\n-    for (const [k, v] of env.entries()) {\r\n-      values[str(unwrap(k))] = v ? 1 : 0;\r\n-    }\r\n+//   const str = (v) =>\r\n+//     v instanceof Array //\r\n+//       ? v.map(str).join(\" \")\r\n+//       : v.toString();\r\n \r\n-    results.push(values);\r\n-  }\r\n+//   for (const env of truthValues(node)) {\r\n+//     evaluate(node, env);\r\n \r\n-  console.table(results);\r\n-};\r\n+//     const values = {};\r\n+//     for (const [k, v] of env.entries()) {\r\n+//       values[str(unwrap(k))] = v ? 1 : 0;\r\n+//     }\r\n \r\n-truthTable(parse(\"(A & B) | !C\"));\r\n+//     results.push(values);\r\n+//   }\r\n+\r\n+//   console.table(results);\r\n+// };\r\n+\r\n+// truthTable(parse(\"(A & B) | !C\"));\r\n"
                },
                {
                    "date": 1698381057867,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,14 +1,12 @@\n+const  IDENTIFIER = RegExp(r\"^\\s*(?!not|and|xor|or)([A-Za-z_$][0-9A-Za-z_$]*)(.*)$\");\r\n+const  L_PAREN = RegExp(r\"^\\s*(\\()(.*)$\");\r\n+const  R_PAREN = RegExp(r\"^\\s*(\\))(.*)$\");\r\n+const  NOT = RegExp(r\"^\\s*(!|not)(.*)$\");\r\n+const  AND = RegExp(r\"^\\s*(&|and)(.*)$\");\r\n+const  XOR = RegExp(r\"^\\s*(\\^|xor)(.*)$\");\r\n+const  OR =RegExp( r\"^\\s*(\\||or)(.*)$\");\r\n \r\n-\r\n-const IDENTIFIER = r\"^\\s*(?!not|and|xor|or)([A-Za-z_$][0-9A-Za-z_$]*)(.*)\\$\";\r\n-const L_PAREN = r\"^\\s*(\\()(.*)\\$\";\r\n-const R_PAREN = r\"^\\s*(\\))(.*)\\$\";\r\n-const NOT = r\"^\\s*(!|not)(.*)\\$\";\r\n-const AND = r\"^\\s*(&|and)(.*)\\$\";\r\n-const XOR = r\"^\\s*(\\^|xor)(.*)\\$\";\r\n-const OR = r\"^\\s*(\\||or)(.*)\\$\";\r\n-\r\n // const parse = (input) => {\r\n //   const binary = (previous, regex, operator) => {\r\n //     return (input) => {\r\n //       let [left, err0, rest] = previous(input);\r\n"
                },
                {
                    "date": 1698381226574,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,208 @@\n+final RegExp IDENTIFIER = RegExp(r\"^\\s*(?!not|and|xor|or)([A-Za-z_$][0-9A-Za-z_$]*)(.*)$\");\r\n+final RegExp L_PAREN = RegExp(r\"^\\s*(\\()(.*)$\");\r\n+final RegExp R_PAREN = RegExp(r\"^\\s*(\\))(.*)$\");\r\n+final RegExp NOT = RegExp(r\"^\\s*(!|not)(.*)$\");\r\n+final RegExp AND = RegExp(r\"^\\s*(&|and)(.*)$\");\r\n+final RegExp XOR = RegExp(r\"^\\s*(\\^|xor)(.*)$\");\r\n+final RegExp OR = RegExp(r\"^\\s*(\\||or)(.*)$\");\r\n+\r\n+\r\n+// const parse = (input) => {\r\n+//   const binary = (previous, regex, operator) => {\r\n+//     return (input) => {\r\n+//       let [left, err0, rest] = previous(input);\r\n+//       if (err0 != null) {\r\n+//         return [null, err0, rest];\r\n+//       }\r\n+\r\n+//       let values = left;\r\n+//       let match;\r\n+//       while ((match = regex.exec(rest))) {\r\n+//         const [right, err1, innerRest] = previous(match[2]);\r\n+//         if (err1 != null) {\r\n+//           return [null, err1, rest];\r\n+//         }\r\n+\r\n+//         values = wrap([values, operator, right]);\r\n+//         rest = innerRest;\r\n+//       }\r\n+\r\n+//       if (values.length <= 1) {\r\n+//         return [values[0], null, rest];\r\n+//       }\r\n+//       return [values, null, rest];\r\n+//     };\r\n+//   };\r\n+\r\n+//   // deno-lint-ignore prefer-const\r\n+//   let parseAtomic, parseUnary, parseAnd, parseXor, parseOr;\r\n+\r\n+//   parseAtomic = (input) => {\r\n+//     let match;\r\n+//     if ((match = IDENTIFIER.exec(input))) {\r\n+//       return [match[1], null, match[2]];\r\n+//     } else if ((match = L_PAREN.exec(input))) {\r\n+//       const [inner, err, rest] = parseOr(match[2]);\r\n+//       if (err != null) {\r\n+//         return [null, err, rest];\r\n+//       }\r\n+\r\n+//       if ((match = R_PAREN.exec(rest))) {\r\n+//         return [wrap(inner), null, match[2]];\r\n+//       } else {\r\n+//         return [null, `Unterminated ')' at \"${rest}\" from \"${input}\"`, rest];\r\n+//       }\r\n+//     }\r\n+//     return [null, `Cannot parse atomic at input: \"${input}\"`];\r\n+//   };\r\n+\r\n+//   parseUnary = (input) => {\r\n+//     let match;\r\n+//     if ((match = NOT.exec(input))) {\r\n+//       const [inner, err, rest] = parseAtomic(match[2]);\r\n+//       if (err == null) {\r\n+//         return [[`~`, inner], null, rest];\r\n+//       }\r\n+//     } else {\r\n+//       return parseAtomic(input);\r\n+//     }\r\n+//   };\r\n+\r\n+//   parseAnd = binary(parseUnary, AND, \"&\");\r\n+//   parseXor = binary(parseAnd, XOR, \"^\");\r\n+//   parseOr = binary(parseXor, OR, \"|\");\r\n+\r\n+//   const [result, error, _] = parseOr(input);\r\n+\r\n+//   if (error != null) {\r\n+//     throw new Error(error);\r\n+//   }\r\n+\r\n+//   return unwrap(result);\r\n+// };\r\n+\r\n+// const matchNode = (node, { parenthesis, binary, unary, atomic }) => {\r\n+//   if (node instanceof Array) {\r\n+//     if (node.length === 3) {\r\n+//       const [left, mid, right] = node;\r\n+\r\n+//       if (left == \"(\" && right == \")\") {\r\n+//         return parenthesis(left, mid, right);\r\n+//       } else {\r\n+//         return binary(left, mid, right);\r\n+//       }\r\n+//     } else if (node.length == 2) {\r\n+//       const [op, value] = node;\r\n+\r\n+//       return unary(op, value);\r\n+//     }\r\n+//   } else {\r\n+//     return atomic(node);\r\n+//   }\r\n+// };\r\n+\r\n+// const evaluate = (node, env) => {\r\n+//   if (env.has(node)) {\r\n+//     return env.get(node);\r\n+//   }\r\n+\r\n+//   matchNode(node, {\r\n+//     parenthesis: (_, mid, __) => env.set(node, evaluate(mid, env)),\r\n+//     binary: (left, mid, right) => {\r\n+//       if (mid === `&`) {\r\n+//         env.set(node, evaluate(left, env) & evaluate(right, env));\r\n+//       } else if (mid === \"|\") {\r\n+//         env.set(node, evaluate(left, env) | evaluate(right, env));\r\n+//       } else if (mid === `^`) {\r\n+//         env.set(node, evaluate(left, env) ^ evaluate(right, env));\r\n+//       } else {\r\n+//         throw new Error(`Unknown operator ${mid}`);\r\n+//       }\r\n+//     },\r\n+//     unary: (op, value) => {\r\n+//       if (op == `~`) {\r\n+//         env.set(node, 1 ^ evaluate(value, env));\r\n+//       } else {\r\n+//         throw new Error(`Unknown unary operator ${op}`);\r\n+//       }\r\n+//     },\r\n+//     atomic: (node) => {\r\n+//       console.log(node);\r\n+//       if (!env.has(node)) {\r\n+//         throw new Error(`Value ${node} is not defined!`);\r\n+//       }\r\n+//     },\r\n+//   });\r\n+//   return env.get(node);\r\n+// };\r\n+// const wrap = (node) => {\r\n+//   if (node instanceof Array && node[0] == \"(\" && node[2] == \")\") {\r\n+//     return node;\r\n+//   }\r\n+//   return [\"(\", node, \")\"];\r\n+// };\r\n+// const unwrap = (node) => {\r\n+//   if (node instanceof Array && node[0] == \"(\" && node[2] == \")\") {\r\n+//     return node[1];\r\n+//   }\r\n+\r\n+//   return node;\r\n+// };\r\n+\r\n+// const variables = (node) => {\r\n+//   return matchNode(node, {\r\n+//     parenthesis: (_, mid, __) => variables(mid),\r\n+//     binary: (left, _, right) => [...variables(left), ...variables(right)],\r\n+//     unary: (_, value) => [...variables(value)],\r\n+//     atomic: (node) => [node],\r\n+//   });\r\n+// };\r\n+\r\n+// const truthValues = (node) => {\r\n+//   const vars = variables(node);\r\n+//   const result = [];\r\n+\r\n+//   const permute = function* (n) {\r\n+//     if (n <= 0) {\r\n+//       yield [];\r\n+//       return;\r\n+//     }\r\n+\r\n+//     for (const permutations of permute(n - 1)) {\r\n+//       yield [0, ...permutations];\r\n+//       yield [1, ...permutations];\r\n+//     }\r\n+//   };\r\n+\r\n+//   for (const startingValues of permute(vars.length)) {\r\n+//     const map = new Map(startingValues.map((v, i) => [vars[i], v]));\r\n+\r\n+//     result.push(map);\r\n+//   }\r\n+\r\n+//   return result;\r\n+// };\r\n+\r\n+// const truthTable = (node) => {\r\n+//   const results = [];\r\n+\r\n+//   const str = (v) =>\r\n+//     v instanceof Array //\r\n+//       ? v.map(str).join(\" \")\r\n+//       : v.toString();\r\n+\r\n+//   for (const env of truthValues(node)) {\r\n+//     evaluate(node, env);\r\n+\r\n+//     const values = {};\r\n+//     for (const [k, v] of env.entries()) {\r\n+//       values[str(unwrap(k))] = v ? 1 : 0;\r\n+//     }\r\n+\r\n+//     results.push(values);\r\n+//   }\r\n+\r\n+//   console.table(results);\r\n+// };\r\n+\r\n+// truthTable(parse(\"(A & B) | !C\"));\r\n"
                },
                {
                    "date": 1698381256699,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -5,216 +5,17 @@\n final RegExp AND = RegExp(r\"^\\s*(&|and)(.*)$\");\r\n final RegExp XOR = RegExp(r\"^\\s*(\\^|xor)(.*)$\");\r\n final RegExp OR = RegExp(r\"^\\s*(\\||or)(.*)$\");\r\n \r\n+sealed class Node {\r\n+  // data class Parenthesis(val left: String, val mid: Node, val right: String) : Node()\r\n+  // data class Binary(val left: Node, val mid: String, val right: Node) : Node()\r\n+  // data class Unary(val op: String, val value: Node) : Node()\r\n+  // data class Atomic(val value: String) : Node()\r\n+}\r\n \r\n-// const parse = (input) => {\r\n-//   const binary = (previous, regex, operator) => {\r\n-//     return (input) => {\r\n-//       let [left, err0, rest] = previous(input);\r\n-//       if (err0 != null) {\r\n-//         return [null, err0, rest];\r\n-//       }\r\n+final class\r\n \r\n-//       let values = left;\r\n-//       let match;\r\n-//       while ((match = regex.exec(rest))) {\r\n-//         const [right, err1, innerRest] = previous(match[2]);\r\n-//         if (err1 != null) {\r\n-//           return [null, err1, rest];\r\n-//         }\r\n-\r\n-//         values = wrap([values, operator, right]);\r\n-//         rest = innerRest;\r\n-//       }\r\n-\r\n-//       if (values.length <= 1) {\r\n-//         return [values[0], null, rest];\r\n-//       }\r\n-//       return [values, null, rest];\r\n-//     };\r\n-//   };\r\n-\r\n-//   // deno-lint-ignore prefer-const\r\n-//   let parseAtomic, parseUnary, parseAnd, parseXor, parseOr;\r\n-\r\n-//   parseAtomic = (input) => {\r\n-//     let match;\r\n-//     if ((match = IDENTIFIER.exec(input))) {\r\n-//       return [match[1], null, match[2]];\r\n-//     } else if ((match = L_PAREN.exec(input))) {\r\n-//       const [inner, err, rest] = parseOr(match[2]);\r\n-//       if (err != null) {\r\n-//         return [null, err, rest];\r\n-//       }\r\n-\r\n-//       if ((match = R_PAREN.exec(rest))) {\r\n-//         return [wrap(inner), null, match[2]];\r\n-//       } else {\r\n-//         return [null, `Unterminated ')' at \"${rest}\" from \"${input}\"`, rest];\r\n-//       }\r\n-//     }\r\n-//     return [null, `Cannot parse atomic at input: \"${input}\"`];\r\n-//   };\r\n-\r\n-//   parseUnary = (input) => {\r\n-//     let match;\r\n-//     if ((match = NOT.exec(input))) {\r\n-//       const [inner, err, rest] = parseAtomic(match[2]);\r\n-//       if (err == null) {\r\n-//         return [[`~`, inner], null, rest];\r\n-//       }\r\n-//     } else {\r\n-//       return parseAtomic(input);\r\n-//     }\r\n-//   };\r\n-\r\n-//   parseAnd = binary(parseUnary, AND, \"&\");\r\n-//   parseXor = binary(parseAnd, XOR, \"^\");\r\n-//   parseOr = binary(parseXor, OR, \"|\");\r\n-\r\n-//   const [result, error, _] = parseOr(input);\r\n-\r\n-//   if (error != null) {\r\n-//     throw new Error(error);\r\n-//   }\r\n-\r\n-//   return unwrap(result);\r\n-// };\r\n-\r\n-// const matchNode = (node, { parenthesis, binary, unary, atomic }) => {\r\n-//   if (node instanceof Array) {\r\n-//     if (node.length === 3) {\r\n-//       const [left, mid, right] = node;\r\n-\r\n-//       if (left == \"(\" && right == \")\") {\r\n-//         return parenthesis(left, mid, right);\r\n-//       } else {\r\n-//         return binary(left, mid, right);\r\n-//       }\r\n-//     } else if (node.length == 2) {\r\n-//       const [op, value] = node;\r\n-\r\n-//       return unary(op, value);\r\n-//     }\r\n-//   } else {\r\n-//     return atomic(node);\r\n-//   }\r\n-// };\r\n-\r\n-// const evaluate = (node, env) => {\r\n-//   if (env.has(node)) {\r\n-//     return env.get(node);\r\n-//   }\r\n-\r\n-//   matchNode(node, {\r\n-//     parenthesis: (_, mid, __) => env.set(node, evaluate(mid, env)),\r\n-//     binary: (left, mid, right) => {\r\n-//       if (mid === `&`) {\r\n-//         env.set(node, evaluate(left, env) & evaluate(right, env));\r\n-//       } else if (mid === \"|\") {\r\n-//         env.set(node, evaluate(left, env) | evaluate(right, env));\r\n-//       } else if (mid === `^`) {\r\n-//         env.set(node, evaluate(left, env) ^ evaluate(right, env));\r\n-//       } else {\r\n-//         throw new Error(`Unknown operator ${mid}`);\r\n-//       }\r\n-//     },\r\n-//     unary: (op, value) => {\r\n-//       if (op == `~`) {\r\n-//         env.set(node, 1 ^ evaluate(value, env));\r\n-//       } else {\r\n-//         throw new Error(`Unknown unary operator ${op}`);\r\n-//       }\r\n-//     },\r\n-//     atomic: (node) => {\r\n-//       console.log(node);\r\n-//       if (!env.has(node)) {\r\n-//         throw new Error(`Value ${node} is not defined!`);\r\n-//       }\r\n-//     },\r\n-//   });\r\n-//   return env.get(node);\r\n-// };\r\n-// const wrap = (node) => {\r\n-//   if (node instanceof Array && node[0] == \"(\" && node[2] == \")\") {\r\n-//     return node;\r\n-//   }\r\n-//   return [\"(\", node, \")\"];\r\n-// };\r\n-// const unwrap = (node) => {\r\n-//   if (node instanceof Array && node[0] == \"(\" && node[2] == \")\") {\r\n-//     return node[1];\r\n-//   }\r\n-\r\n-//   return node;\r\n-// };\r\n-\r\n-// const variables = (node) => {\r\n-//   return matchNode(node, {\r\n-//     parenthesis: (_, mid, __) => variables(mid),\r\n-//     binary: (left, _, right) => [...variables(left), ...variables(right)],\r\n-//     unary: (_, value) => [...variables(value)],\r\n-//     atomic: (node) => [node],\r\n-//   });\r\n-// };\r\n-\r\n-// const truthValues = (node) => {\r\n-//   const vars = variables(node);\r\n-//   const result = [];\r\n-\r\n-//   const permute = function* (n) {\r\n-//     if (n <= 0) {\r\n-//       yield [];\r\n-//       return;\r\n-//     }\r\n-\r\n-//     for (const permutations of permute(n - 1)) {\r\n-//       yield [0, ...permutations];\r\n-//       yield [1, ...permutations];\r\n-//     }\r\n-//   };\r\n-\r\n-//   for (const startingValues of permute(vars.length)) {\r\n-//     const map = new Map(startingValues.map((v, i) => [vars[i], v]));\r\n-\r\n-//     result.push(map);\r\n-//   }\r\n-\r\n-//   return result;\r\n-// };\r\n-\r\n-// const truthTable = (node) => {\r\n-//   const results = [];\r\n-\r\n-//   const str = (v) =>\r\n-//     v instanceof Array //\r\n-//       ? v.map(str).join(\" \")\r\n-//       : v.toString();\r\n-\r\n-//   for (const env of truthValues(node)) {\r\n-//     evaluate(node, env);\r\n-\r\n-//     const values = {};\r\n-//     for (const [k, v] of env.entries()) {\r\n-//       values[str(unwrap(k))] = v ? 1 : 0;\r\n-//     }\r\n-\r\n-//     results.push(values);\r\n-//   }\r\n-\r\n-//   console.table(results);\r\n-// };\r\n-\r\n-// truthTable(parse(\"(A & B) | !C\"));\r\n-const  IDENTIFIER = RegExp(r\"^\\s*(?!not|and|xor|or)([A-Za-z_$][0-9A-Za-z_$]*)(.*)$\");\r\n-const  L_PAREN = RegExp(r\"^\\s*(\\()(.*)$\");\r\n-const  R_PAREN = RegExp(r\"^\\s*(\\))(.*)$\");\r\n-const  NOT = RegExp(r\"^\\s*(!|not)(.*)$\");\r\n-const  AND = RegExp(r\"^\\s*(&|and)(.*)$\");\r\n-const  XOR = RegExp(r\"^\\s*(\\^|xor)(.*)$\");\r\n-const  OR =RegExp( r\"^\\s*(\\||or)(.*)$\");\r\n-\r\n // const parse = (input) => {\r\n //   const binary = (previous, regex, operator) => {\r\n //     return (input) => {\r\n //       let [left, err0, rest] = previous(input);\r\n"
                },
                {
                    "date": 1698381287987,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -12,10 +12,25 @@\n   // data class Unary(val op: String, val value: Node) : Node()\r\n   // data class Atomic(val value: String) : Node()\r\n }\r\n \r\n-final class\r\n+final class Parenthesis implements Node {\r\n+  final String left;\r\n+  final Node mid;\r\n+  final String right;\r\n \r\n+  const Parenthesis(this.left, this.mid, this.right);\r\n+}\r\n+\r\n+final class Binary implements Node {\r\n+  final Node left;\r\n+  final String mid;\r\n+  final Node right;\r\n+\r\n+  const Binary(this.left, this.mid, this.right);\r\n+}\r\n+\r\n+\r\n // const parse = (input) => {\r\n //   const binary = (previous, regex, operator) => {\r\n //     return (input) => {\r\n //       let [left, err0, rest] = previous(input);\r\n"
                },
                {
                    "date": 1698381359628,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -12,8 +12,18 @@\n   // data class Unary(val op: String, val value: Node) : Node()\r\n   // data class Atomic(val value: String) : Node()\r\n }\r\n \r\n+enum BinaryOp {\r\n+  and,\r\n+  xor,\r\n+  or,\r\n+}\r\n+\r\n+enum UnaryOp {\r\n+  not,\r\n+}\r\n+\r\n final class Parenthesis implements Node {\r\n   final String left;\r\n   final Node mid;\r\n   final String right;\r\n@@ -22,15 +32,27 @@\n }\r\n \r\n final class Binary implements Node {\r\n   final Node left;\r\n-  final String mid;\r\n+  final B mid;\r\n   final Node right;\r\n \r\n   const Binary(this.left, this.mid, this.right);\r\n }\r\n \r\n+final class Unary implements Node {\r\n+  final String op;\r\n+  final Node value;\r\n \r\n+  const Unary(this.op, this.value);\r\n+}\r\n+\r\n+final class Atomic implements Node {\r\n+  final String value;\r\n+\r\n+  const Atomic(this.value);\r\n+}\r\n+\r\n // const parse = (input) => {\r\n //   const binary = (previous, regex, operator) => {\r\n //     return (input) => {\r\n //       let [left, err0, rest] = previous(input);\r\n"
                },
                {
                    "date": 1698381390135,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -32,9 +32,9 @@\n }\r\n \r\n final class Binary implements Node {\r\n   final Node left;\r\n-  final B mid;\r\n+  final BinaryOp mid;\r\n   final Node right;\r\n \r\n   const Binary(this.left, this.mid, this.right);\r\n }\r\n@@ -51,8 +51,12 @@\n \r\n   const Atomic(this.value);\r\n }\r\n \r\n+(Node?, Exception?) parse(String input) {\r\n+  ()\r\n+}\r\n+\r\n // const parse = (input) => {\r\n //   const binary = (previous, regex, operator) => {\r\n //     return (input) => {\r\n //       let [left, err0, rest] = previous(input);\r\n"
                },
                {
                    "date": 1698381420218,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -52,9 +52,9 @@\n   const Atomic(this.value);\r\n }\r\n \r\n (Node?, Exception?) parse(String input) {\r\n-  ()\r\n+  (Node?, String?, String) binary(String previo)\r\n }\r\n \r\n // const parse = (input) => {\r\n //   const binary = (previous, regex, operator) => {\r\n"
                },
                {
                    "date": 1698381450396,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -52,9 +52,11 @@\n   const Atomic(this.value);\r\n }\r\n \r\n (Node?, Exception?) parse(String input) {\r\n-  (Node?, String?, String) binary(String previo)\r\n+  (Node?, String?, String) Functin binary(Node? Function(String) previous, RegExp regex, BinaryOp operator) {\r\n+    return (String input)\r\n+  }\r\n }\r\n \r\n // const parse = (input) => {\r\n //   const binary = (previous, regex, operator) => {\r\n"
                },
                {
                    "date": 1698381482196,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -52,10 +52,12 @@\n   const Atomic(this.value);\r\n }\r\n \r\n (Node?, Exception?) parse(String input) {\r\n-  (Node?, String?, String) Functin binary(Node? Function(String) previous, RegExp regex, BinaryOp operator) {\r\n-    return (String input)\r\n+  (Node?, String?, String) Function(String) binary((Node, String?, String? Function(String) previous, RegExp regex, BinaryOp operator) {\r\n+    return (String input) {\r\n+      var (Node left, String? error, String rest) = previous(input);\r\n+    };\r\n   }\r\n }\r\n \r\n // const parse = (input) => {\r\n"
                },
                {
                    "date": 1698381512386,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -52,11 +52,20 @@\n   const Atomic(this.value);\r\n }\r\n \r\n (Node?, Exception?) parse(String input) {\r\n-  (Node?, String?, String) Function(String) binary((Node, String?, String? Function(String) previous, RegExp regex, BinaryOp operator) {\r\n+  (Node?, String?, String) Function(String) binary(\r\n+    (Node, String?, String) Function(String) previous,\r\n+    RegExp regex,\r\n+    BinaryOp operator,\r\n+  ) {\r\n     return (String input) {\r\n-      var (Node left, String? error, String rest) = previous(input);\r\n+      var (Node left, String? err0, String rest) = previous(input);\r\n+      if (err0 != null) {\r\n+        return (null, err0, rest);\r\n+      }\r\n+\r\n+      Node values = left;\r\n     };\r\n   }\r\n }\r\n \r\n"
                },
                {
                    "date": 1698381543151,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -58,14 +58,16 @@\n     RegExp regex,\r\n     BinaryOp operator,\r\n   ) {\r\n     return (String input) {\r\n-      var (Node left, String? err0, String rest) = previous(input);\r\n+      var (Node? left, String? err0, String rest) = previous(input);\r\n       if (err0 != null) {\r\n         return (null, err0, rest);\r\n       }\r\n \r\n-      Node values = left;\r\n+      Node? values = left;\r\n+      Match? match;\r\n+      while ((match = regex.firstMatch(rest)).!)\r\n     };\r\n   }\r\n }\r\n \r\n"
                },
                {
                    "date": 1698381573603,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -65,9 +65,13 @@\n       }\r\n \r\n       Node? values = left;\r\n       Match? match;\r\n-      while ((match = regex.firstMatch(rest)).!)\r\n+      while ((match = regex.firstMatch(rest)) != null) {\r\n+        if (match case RegExpMatch match) {\r\n+          match.groups([0, 1,])\r\n+        }\r\n+      }\r\n     };\r\n   }\r\n }\r\n \r\n"
                },
                {
                    "date": 1698381626269,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -66,10 +66,10 @@\n \r\n       Node? values = left;\r\n       Match? match;\r\n       while ((match = regex.firstMatch(rest)) != null) {\r\n-        if (match case RegExpMatch match) {\r\n-          match.groups([0, 1,])\r\n+        if (match?.groups([0, 1, 2, ]) case [_, String left, String mid, String right]) {\r\n+\r\n         }\r\n       }\r\n     };\r\n   }\r\n"
                },
                {
                    "date": 1698381662929,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -66,10 +66,16 @@\n \r\n       Node? values = left;\r\n       Match? match;\r\n       while ((match = regex.firstMatch(rest)) != null) {\r\n-        if (match?.groups([0, 1, 2, ]) case [_, String left, String mid, String right]) {\r\n+        if (match?.groups([0, 1, 2]) case [_, _, String rest]) {\r\n+          var (Node? right, String? err1, String innerRest) = previous(rest);\r\n+          if (err1 != null) {\r\n+            return (null, err1, rest);\r\n+          }\r\n \r\n+          values = B(values, operator, right);\r\n+          rest = innerRest;\r\n         }\r\n       }\r\n     };\r\n   }\r\n"
                },
                {
                    "date": 1698381695361,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -53,28 +53,28 @@\n }\r\n \r\n (Node?, Exception?) parse(String input) {\r\n   (Node?, String?, String) Function(String) binary(\r\n-    (Node, String?, String) Function(String) previous,\r\n+    (Node?, String?, String) Function(String) previous,\r\n     RegExp regex,\r\n     BinaryOp operator,\r\n   ) {\r\n     return (String input) {\r\n       var (Node? left, String? err0, String rest) = previous(input);\r\n-      if (err0 != null) {\r\n+      if (left == null || err0 != null) {\r\n         return (null, err0, rest);\r\n       }\r\n \r\n-      Node? values = left;\r\n+      Node values = left;\r\n       Match? match;\r\n       while ((match = regex.firstMatch(rest)) != null) {\r\n-        if (match?.groups([0, 1, 2]) case [_, _, String rest]) {\r\n+        if (match?.groups(<int>[0, 1, 2]) case [_, _, String rest]) {\r\n           var (Node? right, String? err1, String innerRest) = previous(rest);\r\n-          if (err1 != null) {\r\n+          if (rerr1 != null) {\r\n             return (null, err1, rest);\r\n           }\r\n \r\n-          values = B(values, operator, right);\r\n+          values = Binary(values, operator, right);\r\n           rest = innerRest;\r\n         }\r\n       }\r\n     };\r\n"
                },
                {
                    "date": 1698381726157,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -68,17 +68,18 @@\n       Match? match;\r\n       while ((match = regex.firstMatch(rest)) != null) {\r\n         if (match?.groups(<int>[0, 1, 2]) case [_, _, String rest]) {\r\n           var (Node? right, String? err1, String innerRest) = previous(rest);\r\n-          if (rerr1 != null) {\r\n+          if (right == null || err1 != null) {\r\n             return (null, err1, rest);\r\n           }\r\n \r\n           values = Binary(values, operator, right);\r\n           rest = innerRest;\r\n         }\r\n       }\r\n-    };\r\n+\r\n+      return values\r\n   }\r\n }\r\n \r\n // const parse = (input) => {\r\n"
                },
                {
                    "date": 1698381756184,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -77,39 +77,16 @@\n           rest = innerRest;\r\n         }\r\n       }\r\n \r\n-      return values\r\n+      return (values, null, rest);\r\n+    };\r\n   }\r\n+  \r\n }\r\n \r\n // const parse = (input) => {\r\n-//   const binary = (previous, regex, operator) => {\r\n-//     return (input) => {\r\n-//       let [left, err0, rest] = previous(input);\r\n-//       if (err0 != null) {\r\n-//         return [null, err0, rest];\r\n-//       }\r\n \r\n-//       let values = left;\r\n-//       let match;\r\n-//       while ((match = regex.exec(rest))) {\r\n-//         const [right, err1, innerRest] = previous(match[2]);\r\n-//         if (err1 != null) {\r\n-//           return [null, err1, rest];\r\n-//         }\r\n-\r\n-//         values = wrap([values, operator, right]);\r\n-//         rest = innerRest;\r\n-//       }\r\n-\r\n-//       if (values.length <= 1) {\r\n-//         return [values[0], null, rest];\r\n-//       }\r\n-//       return [values, null, rest];\r\n-//     };\r\n-//   };\r\n-\r\n //   // deno-lint-ignore prefer-const\r\n //   let parseAtomic, parseUnary, parseAnd, parseXor, parseOr;\r\n \r\n //   parseAtomic = (input) => {\r\n"
                },
                {
                    "date": 1698381786323,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -80,9 +80,13 @@\n \r\n       return (values, null, rest);\r\n     };\r\n   }\r\n-  \r\n+\r\n+  (Node?, String?, String) parseAtomic(String input) {\r\n+    RegExpMatch? match;\r\n+    if (IDENTIFIER.firstMatc)\r\n+  }\r\n }\r\n \r\n // const parse = (input) => {\r\n \r\n"
                },
                {
                    "date": 1698381816446,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -65,8 +65,11 @@\n       }\r\n \r\n       Node values = left;\r\n       Match? match;\r\n+      while (true) {\r\n+        if() {} \r\n+      }\r\n       while ((match = regex.firstMatch(rest)) != null) {\r\n         if (match?.groups(<int>[0, 1, 2]) case [_, _, String rest]) {\r\n           var (Node? right, String? err1, String innerRest) = previous(rest);\r\n           if (right == null || err1 != null) {\r\n@@ -82,10 +85,9 @@\n     };\r\n   }\r\n \r\n   (Node?, String?, String) parseAtomic(String input) {\r\n-    RegExpMatch? match;\r\n-    if (IDENTIFIER.firstMatc)\r\n+    if (IDENTIFIER.firstMatch(input) case RegExpMatch match) {}\r\n   }\r\n }\r\n \r\n // const parse = (input) => {\r\n"
                },
                {
                    "date": 1698381849663,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -64,21 +64,16 @@\n         return (null, err0, rest);\r\n       }\r\n \r\n       Node values = left;\r\n-      Match? match;\r\n       while (true) {\r\n-        if() {} \r\n+        if (regex.firstMatch(rest)?.groups([0, 1, 2]) case [_, _, String rest]) {\r\n+        } else {\r\n+          break;\r\n+        }\r\n       }\r\n       while ((match = regex.firstMatch(rest)) != null) {\r\n         if (match?.groups(<int>[0, 1, 2]) case [_, _, String rest]) {\r\n-          var (Node? right, String? err1, String innerRest) = previous(rest);\r\n-          if (right == null || err1 != null) {\r\n-            return (null, err1, rest);\r\n-          }\r\n-\r\n-          values = Binary(values, operator, right);\r\n-          rest = innerRest;\r\n         }\r\n       }\r\n \r\n       return (values, null, rest);\r\n"
                },
                {
                    "date": 1698381882893,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -65,24 +65,28 @@\n       }\r\n \r\n       Node values = left;\r\n       while (true) {\r\n-        if (regex.firstMatch(rest)?.groups([0, 1, 2]) case [_, _, String rest]) {\r\n+        if (regex.firstMatch(rest)?.groups(<int>[0, 1, 2]) case [_, _, String rest]) {\r\n+          var (Node? right, String? err1, String innerRest) = previous(rest);\r\n+          if (right == null || err1 != null) {\r\n+            return (null, err1, rest);\r\n+          }\r\n+\r\n+          values = Binary(values, operator, right);\r\n+          rest = innerRest;\r\n         } else {\r\n           break;\r\n         }\r\n       }\r\n-      while ((match = regex.firstMatch(rest)) != null) {\r\n-        if (match?.groups(<int>[0, 1, 2]) case [_, _, String rest]) {\r\n-        }\r\n-      }\r\n-\r\n       return (values, null, rest);\r\n     };\r\n   }\r\n \r\n   (Node?, String?, String) parseAtomic(String input) {\r\n-    if (IDENTIFIER.firstMatch(input) case RegExpMatch match) {}\r\n+    if (IDENTIFIER.firstMatch(input)?.groups(<int>[0, 1, 2]) case [RegExpMatch match]) {\r\n+      return ()\r\n+    }\r\n   }\r\n }\r\n \r\n // const parse = (input) => {\r\n"
                },
                {
                    "date": 1698381915029,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -82,11 +82,11 @@\n     };\r\n   }\r\n \r\n   (Node?, String?, String) parseAtomic(String input) {\r\n-    if (IDENTIFIER.firstMatch(input)?.groups(<int>[0, 1, 2]) case [RegExpMatch match]) {\r\n-      return ()\r\n-    }\r\n+    if (IDENTIFIER.firstMatch(input)?.groups(<int>[0, 1, 2]) case [_, String value, String rest]) {\r\n+      return (Atomic(value), null, rest);\r\n+    } \r\n   }\r\n }\r\n \r\n // const parse = (input) => {\r\n"
                },
                {
                    "date": 1698381945111,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -84,9 +84,9 @@\n \r\n   (Node?, String?, String) parseAtomic(String input) {\r\n     if (IDENTIFIER.firstMatch(input)?.groups(<int>[0, 1, 2]) case [_, String value, String rest]) {\r\n       return (Atomic(value), null, rest);\r\n-    } \r\n+    } else if (L_PAREN.firstMatch(input)?)\r\n   }\r\n }\r\n \r\n // const parse = (input) => {\r\n@@ -262,4 +262,8 @@\n //   console.table(results);\r\n // };\r\n \r\n // truthTable(parse(\"(A & B) | !C\"));\r\n+\r\n+extension on RegExp {\r\n+  List<String?> exec(String inp)\r\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1698381975167,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -264,6 +264,8 @@\n \r\n // truthTable(parse(\"(A & B) | !C\"));\r\n \r\n extension on RegExp {\r\n-  List<String?> exec(String inp)\r\n+  List<String?>? exec(String input, [int index = 0]) {\r\n+    if (this.matchAsPrefix(input, index) case RegExpMa)\r\n+  }\r\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1698382005880,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -265,7 +265,9 @@\n // truthTable(parse(\"(A & B) | !C\"));\r\n \r\n extension on RegExp {\r\n   List<String?>? exec(String input, [int index = 0]) {\r\n-    if (this.matchAsPrefix(input, index) case RegExpMa)\r\n+    if (this.matchAsPrefix(input, index) case RegExpMatch match) {\r\n+      if (match.groups([for (int i = 0; i < match.groupCount; ++i) i]) )\r\n+    }\r\n   }\r\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1698382037425,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -65,9 +65,9 @@\n       }\r\n \r\n       Node values = left;\r\n       while (true) {\r\n-        if (regex.firstMatch(rest)?.groups(<int>[0, 1, 2]) case [_, _, String rest]) {\r\n+        if (regex.ecase [_, _, String rest]) {\r\n           var (Node? right, String? err1, String innerRest) = previous(rest);\r\n           if (right == null || err1 != null) {\r\n             return (null, err1, rest);\r\n           }\r\n@@ -82,9 +82,9 @@\n     };\r\n   }\r\n \r\n   (Node?, String?, String) parseAtomic(String input) {\r\n-    if (IDENTIFIER.firstMatch(input)?.groups(<int>[0, 1, 2]) case [_, String value, String rest]) {\r\n+    if (IDENTIFIER.exec(input) case [_, String value, String rest]) {\r\n       return (Atomic(value), null, rest);\r\n     } else if (L_PAREN.firstMatch(input)?)\r\n   }\r\n }\r\n@@ -266,8 +266,11 @@\n \r\n extension on RegExp {\r\n   List<String?>? exec(String input, [int index = 0]) {\r\n     if (this.matchAsPrefix(input, index) case RegExpMatch match) {\r\n-      if (match.groups([for (int i = 0; i < match.groupCount; ++i) i]) )\r\n+      if (match.groups(<int>[for (int i = 0; i < match.groupCount; ++i) i]) case List<String?> matches) {\r\n+        return matches;\r\n+      }\r\n\\ No newline at end of file\n     }\r\n+    return null;\r\n   }\r\n-}\n+}\r\n"
                },
                {
                    "date": 1698382068005,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -65,9 +65,9 @@\n       }\r\n \r\n       Node values = left;\r\n       while (true) {\r\n-        if (regex.ecase [_, _, String rest]) {\r\n+        if (regex.exec(rest) case [_, _, String rest]) {\r\n           var (Node? right, String? err1, String innerRest) = previous(rest);\r\n           if (right == null || err1 != null) {\r\n             return (null, err1, rest);\r\n           }\r\n@@ -84,9 +84,9 @@\n \r\n   (Node?, String?, String) parseAtomic(String input) {\r\n     if (IDENTIFIER.exec(input) case [_, String value, String rest]) {\r\n       return (Atomic(value), null, rest);\r\n-    } else if (L_PAREN.firstMatch(input)?)\r\n+    } else if (L_PAREN.exec(input) case [\"(\", String rest])]\r\n   }\r\n }\r\n \r\n // const parse = (input) => {\r\n@@ -272,5 +272,5 @@\n       }\r\n     }\r\n     return null;\r\n   }\r\n-}\n\\ No newline at end of file\n+}\r\n"
                },
                {
                    "date": 1698382098092,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -81,9 +81,9 @@\n       return (values, null, rest);\r\n     };\r\n   }\r\n \r\n-  late (Node?, String?, String) Function(String) parseAtomi\r\n+  late (Node?, String?, String) Function(String) parseAtomic\r\n \r\n   (Node?, String?, String) parseAtomic(String input) {\r\n     if (IDENTIFIER.exec(input) case [_, String value, String rest]) {\r\n       return (Atomic(value), null, rest);\r\n"
                },
                {
                    "date": 1698382130667,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -82,9 +82,9 @@\n     };\r\n   }\r\n \r\n   late (Node?, String?, String) Function(String) parseAtomic;\r\n-  late (Node?, String?, String) Function(String) par;\r\n+  late (Node?, String?, String) Function(String) pars;\r\n   late (Node?, String?, String) Function(String) parseAtomic;\r\n   late (Node?, String?, String) Function(String) parseAtomic;\r\n \r\n   parseAtomic = (String input) {\r\n"
                }
            ],
            "date": 1698380991998,
            "name": "Commit-0",
            "content": "const IDENTIFIER = /^\\s*(?!not|and|xor|or)([A-Za-z_$][0-9A-Za-z_$]*)(.*)$/;\r\nconst L_PAREN = /^\\s*(\\()(.*)$/;\r\nconst R_PAREN = /^\\s*(\\))(.*)$/;\r\nconst NOT = /^\\s*(!|not)(.*)$/;\r\nconst AND = /^\\s*(&|and)(.*)$/;\r\nconst XOR = /^\\s*(\\^|xor)(.*)$/;\r\nconst OR = /^\\s*(\\||or)(.*)$/;\r\n\r\nconst parse = (input) => {\r\n  const binary = (previous, regex, operator) => {\r\n    return (input) => {\r\n      let [left, err0, rest] = previous(input);\r\n      if (err0 != null) {\r\n        return [null, err0, rest];\r\n      }\r\n\r\n      let values = left;\r\n      let match;\r\n      while ((match = regex.exec(rest))) {\r\n        const [right, err1, innerRest] = previous(match[2]);\r\n        if (err1 != null) {\r\n          return [null, err1, rest];\r\n        }\r\n\r\n        values = wrap([values, operator, right]);\r\n        rest = innerRest;\r\n      }\r\n\r\n      if (values.length <= 1) {\r\n        return [values[0], null, rest];\r\n      }\r\n      return [values, null, rest];\r\n    };\r\n  };\r\n\r\n  // deno-lint-ignore prefer-const\r\n  let parseAtomic, parseUnary, parseAnd, parseXor, parseOr;\r\n\r\n  parseAtomic = (input) => {\r\n    let match;\r\n    if ((match = IDENTIFIER.exec(input))) {\r\n      return [match[1], null, match[2]];\r\n    } else if ((match = L_PAREN.exec(input))) {\r\n      const [inner, err, rest] = parseOr(match[2]);\r\n      if (err != null) {\r\n        return [null, err, rest];\r\n      }\r\n\r\n      if ((match = R_PAREN.exec(rest))) {\r\n        return [wrap(inner), null, match[2]];\r\n      } else {\r\n        return [null, `Unterminated ')' at \"${rest}\" from \"${input}\"`, rest];\r\n      }\r\n    }\r\n    return [null, `Cannot parse atomic at input: \"${input}\"`];\r\n  };\r\n\r\n  parseUnary = (input) => {\r\n    let match;\r\n    if ((match = NOT.exec(input))) {\r\n      const [inner, err, rest] = parseAtomic(match[2]);\r\n      if (err == null) {\r\n        return [[`~`, inner], null, rest];\r\n      }\r\n    } else {\r\n      return parseAtomic(input);\r\n    }\r\n  };\r\n\r\n  parseAnd = binary(parseUnary, AND, \"&\");\r\n  parseXor = binary(parseAnd, XOR, \"^\");\r\n  parseOr = binary(parseXor, OR, \"|\");\r\n\r\n  const [result, error, _] = parseOr(input);\r\n\r\n  if (error != null) {\r\n    throw new Error(error);\r\n  }\r\n\r\n  return unwrap(result);\r\n};\r\n\r\nconst matchNode = (node, { parenthesis, binary, unary, atomic }) => {\r\n  if (node instanceof Array) {\r\n    if (node.length === 3) {\r\n      const [left, mid, right] = node;\r\n\r\n      if (left == \"(\" && right == \")\") {\r\n        return parenthesis(left, mid, right);\r\n      } else {\r\n        return binary(left, mid, right);\r\n      }\r\n    } else if (node.length == 2) {\r\n      const [op, value] = node;\r\n\r\n      return unary(op, value);\r\n    }\r\n  } else {\r\n    return atomic(node);\r\n  }\r\n};\r\n\r\nconst evaluate = (node, env) => {\r\n  if (env.has(node)) {\r\n    return env.get(node);\r\n  }\r\n\r\n  matchNode(node, {\r\n    parenthesis: (_, mid, __) => env.set(node, evaluate(mid, env)),\r\n    binary: (left, mid, right) => {\r\n      if (mid === `&`) {\r\n        env.set(node, evaluate(left, env) & evaluate(right, env));\r\n      } else if (mid === \"|\") {\r\n        env.set(node, evaluate(left, env) | evaluate(right, env));\r\n      } else if (mid === `^`) {\r\n        env.set(node, evaluate(left, env) ^ evaluate(right, env));\r\n      } else {\r\n        throw new Error(`Unknown operator ${mid}`);\r\n      }\r\n    },\r\n    unary: (op, value) => {\r\n      if (op == `~`) {\r\n        env.set(node, 1 ^ evaluate(value, env));\r\n      } else {\r\n        throw new Error(`Unknown unary operator ${op}`);\r\n      }\r\n    },\r\n    atomic: (node) => {\r\n      console.log(node);\r\n      if (!env.has(node)) {\r\n        throw new Error(`Value ${node} is not defined!`);\r\n      }\r\n    },\r\n  });\r\n  return env.get(node);\r\n};\r\nconst wrap = (node) => {\r\n  if (node instanceof Array && node[0] == \"(\" && node[2] == \")\") {\r\n    return node;\r\n  }\r\n  return [\"(\", node, \")\"];\r\n};\r\nconst unwrap = (node) => {\r\n  if (node instanceof Array && node[0] == \"(\" && node[2] == \")\") {\r\n    return node[1];\r\n  }\r\n\r\n  return node;\r\n};\r\n\r\nconst variables = (node) => {\r\n  return matchNode(node, {\r\n    parenthesis: (_, mid, __) => variables(mid),\r\n    binary: (left, _, right) => [...variables(left), ...variables(right)],\r\n    unary: (_, value) => [...variables(value)],\r\n    atomic: (node) => [node],\r\n  });\r\n};\r\n\r\nconst truthValues = (node) => {\r\n  const vars = variables(node);\r\n  const result = [];\r\n\r\n  const permute = function* (n) {\r\n    if (n <= 0) {\r\n      yield [];\r\n      return;\r\n    }\r\n\r\n    for (const permutations of permute(n - 1)) {\r\n      yield [0, ...permutations];\r\n      yield [1, ...permutations];\r\n    }\r\n  };\r\n\r\n  for (const startingValues of permute(vars.length)) {\r\n    const map = new Map(startingValues.map((v, i) => [vars[i], v]));\r\n\r\n    result.push(map);\r\n  }\r\n\r\n  return result;\r\n};\r\n\r\nconst truthTable = (node) => {\r\n  const results = [];\r\n\r\n  const str = (v) =>\r\n    v instanceof Array //\r\n      ? v.map(str).join(\" \")\r\n      : v.toString();\r\n\r\n  for (const env of truthValues(node)) {\r\n    evaluate(node, env);\r\n\r\n    const values = {};\r\n    for (const [k, v] of env.entries()) {\r\n      values[str(unwrap(k))] = v ? 1 : 0;\r\n    }\r\n\r\n    results.push(values);\r\n  }\r\n\r\n  console.table(results);\r\n};\r\n\r\ntruthTable(parse(\"(A & B) | !C\"));\r\n"
        }
    ]
}