{
    "sourceFile": "lib/main.dart",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 3,
            "patches": [
                {
                    "date": 1687855651690,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1687855687148,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -52,15 +52,17 @@\n   }\r\n }\r\n \r\n int calculateMinRun(int n, int minRun) {\r\n-  int r = 0;\r\n-  while (n >= minRun) {\r\n-    r |= (n & 1);\r\n-    n ~/= 2;\r\n+  if (n case int length) {\r\n+    int r = 0;\r\n+    while (length >= minRun) {\r\n+      r |= length & 1;\r\n+      length ~/= 2;\r\n+    }\r\n+\r\n+    return length + r;\r\n   }\r\n-\r\n-  return n + r;\r\n }\r\n \r\n void timSort(List<int> arr) {\r\n   int n = arr.length;\r\n@@ -83,13 +85,13 @@\n }\r\n \r\n void main() {\r\n   /// A random list of 255 values\r\n-  List<int> values = List<int>.generate(20000, (i) => i + 1)..shuffle();\r\n+  List<int> values = List<int>.generate(20000, (int i) => i + 1)..shuffle();\r\n   print(values.isSorted);\r\n   timSort(values);\r\n   print(values.isSorted);\r\n }\r\n \r\n extension on List<int> {\r\n-  bool get isSorted => length < 2 || indexed.skip(1).every((e) => this[e.$1 - 1] <= e.$2);\r\n+  bool get isSorted => length < 2 || indexed.skip(1).every(((int, int) e) => this[e.$1 - 1] <= e.$2);\r\n }\r\n"
                },
                {
                    "date": 1687855750622,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,97 +0,0 @@\n-void insertionSort(List<int> arr, int left, int right) {\r\n-  for (int i = left + 1; i <= right; i++) {\r\n-    int key = arr[i];\r\n-    int j = i - 1;\r\n-    while (j >= left && arr[j] > key) {\r\n-      arr[j + 1] = arr[j];\r\n-      j--;\r\n-    }\r\n-    arr[j + 1] = key;\r\n-  }\r\n-}\r\n-\r\n-void merge(List<int> arr, int left, int mid, int right) {\r\n-  int len1 = mid - left + 1;\r\n-  int len2 = right - mid;\r\n-\r\n-  List<int> leftArr = List<int>.filled(len1, 0);\r\n-  List<int> rightArr = List<int>.filled(len2, 0);\r\n-\r\n-  for (int i = 0; i < len1; i++) {\r\n-    leftArr[i] = arr[left + i];\r\n-  }\r\n-  for (int i = 0; i < len2; i++) {\r\n-    rightArr[i] = arr[mid + 1 + i];\r\n-  }\r\n-\r\n-  int i = 0;\r\n-  int j = 0;\r\n-  int k = left;\r\n-\r\n-  while (i < len1 && j < len2) {\r\n-    if (leftArr[i] <= rightArr[j]) {\r\n-      arr[k] = leftArr[i];\r\n-      i++;\r\n-    } else {\r\n-      arr[k] = rightArr[j];\r\n-      j++;\r\n-    }\r\n-    k++;\r\n-  }\r\n-\r\n-  while (i < len1) {\r\n-    arr[k] = leftArr[i];\r\n-    i++;\r\n-    k++;\r\n-  }\r\n-\r\n-  while (j < len2) {\r\n-    arr[k] = rightArr[j];\r\n-    j++;\r\n-    k++;\r\n-  }\r\n-}\r\n-\r\n-int calculateMinRun(int n, int minRun) {\r\n-  if (n case int length) {\r\n-    int r = 0;\r\n-    while (length >= minRun) {\r\n-      r |= length & 1;\r\n-      length ~/= 2;\r\n-    }\r\n-\r\n-    return length + r;\r\n-  }\r\n-}\r\n-\r\n-void timSort(List<int> arr) {\r\n-  int n = arr.length;\r\n-  int minRun = calculateMinRun(n, 64);\r\n-  print(minRun);\r\n-\r\n-  for (int i = 0; i < n; i += minRun) {\r\n-    insertionSort(arr, i, (i + minRun - 1 < n - 1) ? (i + minRun - 1) : (n - 1));\r\n-  }\r\n-\r\n-  int size = minRun;\r\n-  while (size < n) {\r\n-    for (int left = 0; left < n; left += 2 * size) {\r\n-      int mid = left + size - 1;\r\n-      int right = ((left + 2 * size - 1) < (n - 1)) ? (left + 2 * size - 1) : (n - 1);\r\n-      merge(arr, left, mid, right);\r\n-    }\r\n-    size *= 2;\r\n-  }\r\n-}\r\n-\r\n-void main() {\r\n-  /// A random list of 255 values\r\n-  List<int> values = List<int>.generate(20000, (int i) => i + 1)..shuffle();\r\n-  print(values.isSorted);\r\n-  timSort(values);\r\n-  print(values.isSorted);\r\n-}\r\n-\r\n-extension on List<int> {\r\n-  bool get isSorted => length < 2 || indexed.skip(1).every(((int, int) e) => this[e.$1 - 1] <= e.$2);\r\n-}\r\n\\ No newline at end of file\n"
                },
                {
                    "date": 1687855780950,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,1 @@\n+inline class MyInlineClass \r\n"
                }
            ],
            "date": 1687855651690,
            "name": "Commit-0",
            "content": "void insertionSort(List<int> arr, int left, int right) {\r\n  for (int i = left + 1; i <= right; i++) {\r\n    int key = arr[i];\r\n    int j = i - 1;\r\n    while (j >= left && arr[j] > key) {\r\n      arr[j + 1] = arr[j];\r\n      j--;\r\n    }\r\n    arr[j + 1] = key;\r\n  }\r\n}\r\n\r\nvoid merge(List<int> arr, int left, int mid, int right) {\r\n  int len1 = mid - left + 1;\r\n  int len2 = right - mid;\r\n\r\n  List<int> leftArr = List<int>.filled(len1, 0);\r\n  List<int> rightArr = List<int>.filled(len2, 0);\r\n\r\n  for (int i = 0; i < len1; i++) {\r\n    leftArr[i] = arr[left + i];\r\n  }\r\n  for (int i = 0; i < len2; i++) {\r\n    rightArr[i] = arr[mid + 1 + i];\r\n  }\r\n\r\n  int i = 0;\r\n  int j = 0;\r\n  int k = left;\r\n\r\n  while (i < len1 && j < len2) {\r\n    if (leftArr[i] <= rightArr[j]) {\r\n      arr[k] = leftArr[i];\r\n      i++;\r\n    } else {\r\n      arr[k] = rightArr[j];\r\n      j++;\r\n    }\r\n    k++;\r\n  }\r\n\r\n  while (i < len1) {\r\n    arr[k] = leftArr[i];\r\n    i++;\r\n    k++;\r\n  }\r\n\r\n  while (j < len2) {\r\n    arr[k] = rightArr[j];\r\n    j++;\r\n    k++;\r\n  }\r\n}\r\n\r\nint calculateMinRun(int n, int minRun) {\r\n  int r = 0;\r\n  while (n >= minRun) {\r\n    r |= (n & 1);\r\n    n ~/= 2;\r\n  }\r\n\r\n  return n + r;\r\n}\r\n\r\nvoid timSort(List<int> arr) {\r\n  int n = arr.length;\r\n  int minRun = calculateMinRun(n, 64);\r\n  print(minRun);\r\n\r\n  for (int i = 0; i < n; i += minRun) {\r\n    insertionSort(arr, i, (i + minRun - 1 < n - 1) ? (i + minRun - 1) : (n - 1));\r\n  }\r\n\r\n  int size = minRun;\r\n  while (size < n) {\r\n    for (int left = 0; left < n; left += 2 * size) {\r\n      int mid = left + size - 1;\r\n      int right = ((left + 2 * size - 1) < (n - 1)) ? (left + 2 * size - 1) : (n - 1);\r\n      merge(arr, left, mid, right);\r\n    }\r\n    size *= 2;\r\n  }\r\n}\r\n\r\nvoid main() {\r\n  /// A random list of 255 values\r\n  List<int> values = List<int>.generate(20000, (i) => i + 1)..shuffle();\r\n  print(values.isSorted);\r\n  timSort(values);\r\n  print(values.isSorted);\r\n}\r\n\r\nextension on List<int> {\r\n  bool get isSorted => length < 2 || indexed.skip(1).every((e) => this[e.$1 - 1] <= e.$2);\r\n}\r\n"
        }
    ]
}